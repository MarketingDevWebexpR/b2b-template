{"version":3,"sources":["../../src/utils/index.ts","../../src/utils/approval-rules.ts","../../src/utils/spending-calculator.ts","../../src/utils/csv-parser.ts","../../src/utils/format.ts"],"sourcesContent":["// Approval Rules\nexport {\n  canAutoApprove,\n  createAmountRule,\n  createDepartmentRule,\n  createRoleRule,\n  DEFAULT_APPROVAL_RULES,\n  evaluateCondition,\n  evaluateRule,\n  evaluateRules,\n  getRequiredApprovers,\n  requiresApproval,\n  shouldReject,\n} from \"./approval-rules\";\nexport type {\n  ApprovalRule,\n  RuleAction,\n  RuleActionType,\n  RuleCondition,\n  RuleConditionType,\n  RuleEvaluationContext,\n  RuleEvaluationResult,\n} from \"./approval-rules\";\n\n// Spending Calculator\nexport {\n  calculateByCategory,\n  calculateByDay,\n  calculateEffectiveLimit,\n  calculateRollover,\n  calculateSavingsOpportunity,\n  calculateSpending,\n  calculateTotal,\n  calculateTrend,\n  canMakePurchase,\n  daysBetween,\n  filterByPeriod,\n  generateForecast,\n  getPeriodDates,\n} from \"./spending-calculator\";\nexport type {\n  SpendingCalculation,\n  SpendingLimitConfig,\n  SpendingPeriodType,\n  SpendingRecord,\n} from \"./spending-calculator\";\n\n// CSV Parser\nexport {\n  EMPLOYEE_COLUMN_MAPPINGS,\n  generateCsv,\n  generateTemplate,\n  mapColumns,\n  parseCsv,\n  readAndParseCsv,\n  readFileAsText,\n  validateFileSize,\n} from \"./csv-parser\";\nexport type {\n  ColumnMapping,\n  CsvParseError,\n  CsvParseOptions,\n  CsvParseResult,\n} from \"./csv-parser\";\n\n// Formatters\nexport {\n  formatAddress,\n  formatCompanyName,\n  formatCurrency,\n  formatCurrencyCompact,\n  formatDate,\n  formatDuration,\n  formatFileSize,\n  formatInvoiceNumber,\n  formatNumber,\n  formatOrderNumber,\n  formatPaymentTerms,\n  formatPercentage,\n  formatPhoneNumber,\n  formatQuantity,\n  formatQuoteNumber,\n  formatRelativeDate,\n  formatVatId,\n  truncateText,\n} from \"./format\";\nexport type {\n  CurrencyFormatOptions,\n  DateFormatOptions,\n  NumberFormatOptions,\n} from \"./format\";\n","/**\n * Approval Rules Utilities\n *\n * Functions for evaluating approval rules in B2B workflows.\n */\n\n/**\n * Approval rule condition type\n */\nexport type RuleConditionType =\n  | \"amount_greater_than\"\n  | \"amount_less_than\"\n  | \"amount_between\"\n  | \"quantity_greater_than\"\n  | \"quantity_less_than\"\n  | \"category_in\"\n  | \"category_not_in\"\n  | \"user_role_in\"\n  | \"user_role_not_in\"\n  | \"department_in\"\n  | \"department_not_in\"\n  | \"cost_center_in\"\n  | \"cost_center_not_in\"\n  | \"vendor_in\"\n  | \"vendor_not_in\"\n  | \"custom\";\n\n/**\n * Approval rule condition\n */\nexport interface RuleCondition {\n  type: RuleConditionType;\n  value: unknown;\n  valueTo?: unknown; // For 'between' conditions\n}\n\n/**\n * Approval rule action\n */\nexport type RuleActionType =\n  | \"auto_approve\"\n  | \"require_approval\"\n  | \"require_multi_approval\"\n  | \"escalate\"\n  | \"reject\"\n  | \"notify\";\n\n/**\n * Approval rule action configuration\n */\nexport interface RuleAction {\n  type: RuleActionType;\n  /** Approver IDs (for require_approval) */\n  approverIds?: string[];\n  /** Number of approvals required (for multi_approval) */\n  requiredApprovals?: number;\n  /** Escalation target ID */\n  escalateTo?: string;\n  /** Notification message */\n  message?: string;\n  /** Notification recipients */\n  notifyRecipients?: string[];\n}\n\n/**\n * Complete approval rule\n */\nexport interface ApprovalRule {\n  id: string;\n  name: string;\n  description?: string;\n  /** Conditions that must all be met (AND logic) */\n  conditions: RuleCondition[];\n  /** Action to take when rule matches */\n  action: RuleAction;\n  /** Rule priority (lower = higher priority) */\n  priority: number;\n  /** Whether rule is active */\n  isActive: boolean;\n}\n\n/**\n * Context for rule evaluation\n */\nexport interface RuleEvaluationContext {\n  /** Order/request amount */\n  amount?: number;\n  /** Total quantity */\n  quantity?: number;\n  /** Item categories */\n  categories?: string[];\n  /** User role */\n  userRole?: string;\n  /** User department */\n  department?: string;\n  /** Cost center */\n  costCenter?: string;\n  /** Vendor/supplier ID */\n  vendorId?: string;\n  /** Custom data for custom conditions */\n  customData?: Record<string, unknown>;\n}\n\n/**\n * Rule evaluation result\n */\nexport interface RuleEvaluationResult {\n  /** Whether any rule matched */\n  matched: boolean;\n  /** Matching rule (if any) */\n  matchedRule?: ApprovalRule;\n  /** Action to take */\n  action?: RuleAction;\n  /** All evaluated rules with their match status */\n  evaluations: Array<{\n    rule: ApprovalRule;\n    matched: boolean;\n    failedConditions: RuleCondition[];\n  }>;\n}\n\n/**\n * Evaluate a single condition against context\n */\nexport function evaluateCondition(\n  condition: RuleCondition,\n  context: RuleEvaluationContext\n): boolean {\n  switch (condition.type) {\n    case \"amount_greater_than\":\n      return (\n        context.amount !== undefined &&\n        context.amount > (condition.value as number)\n      );\n\n    case \"amount_less_than\":\n      return (\n        context.amount !== undefined &&\n        context.amount < (condition.value as number)\n      );\n\n    case \"amount_between\":\n      return (\n        context.amount !== undefined &&\n        context.amount >= (condition.value as number) &&\n        context.amount <= (condition.valueTo as number)\n      );\n\n    case \"quantity_greater_than\":\n      return (\n        context.quantity !== undefined &&\n        context.quantity > (condition.value as number)\n      );\n\n    case \"quantity_less_than\":\n      return (\n        context.quantity !== undefined &&\n        context.quantity < (condition.value as number)\n      );\n\n    case \"category_in\":\n      return (\n        context.categories !== undefined &&\n        (condition.value as string[]).some((cat) =>\n          context.categories!.includes(cat)\n        )\n      );\n\n    case \"category_not_in\":\n      return (\n        context.categories !== undefined &&\n        !(condition.value as string[]).some((cat) =>\n          context.categories!.includes(cat)\n        )\n      );\n\n    case \"user_role_in\":\n      return (\n        context.userRole !== undefined &&\n        (condition.value as string[]).includes(context.userRole)\n      );\n\n    case \"user_role_not_in\":\n      return (\n        context.userRole !== undefined &&\n        !(condition.value as string[]).includes(context.userRole)\n      );\n\n    case \"department_in\":\n      return (\n        context.department !== undefined &&\n        (condition.value as string[]).includes(context.department)\n      );\n\n    case \"department_not_in\":\n      return (\n        context.department !== undefined &&\n        !(condition.value as string[]).includes(context.department)\n      );\n\n    case \"cost_center_in\":\n      return (\n        context.costCenter !== undefined &&\n        (condition.value as string[]).includes(context.costCenter)\n      );\n\n    case \"cost_center_not_in\":\n      return (\n        context.costCenter !== undefined &&\n        !(condition.value as string[]).includes(context.costCenter)\n      );\n\n    case \"vendor_in\":\n      return (\n        context.vendorId !== undefined &&\n        (condition.value as string[]).includes(context.vendorId)\n      );\n\n    case \"vendor_not_in\":\n      return (\n        context.vendorId !== undefined &&\n        !(condition.value as string[]).includes(context.vendorId)\n      );\n\n    case \"custom\":\n      // Custom conditions require a custom evaluator\n      // The value should be a function or key to look up in customData\n      if (typeof condition.value === \"function\") {\n        return (condition.value as (ctx: RuleEvaluationContext) => boolean)(\n          context\n        );\n      }\n      return false;\n\n    default:\n      return false;\n  }\n}\n\n/**\n * Evaluate a single rule against context\n */\nexport function evaluateRule(\n  rule: ApprovalRule,\n  context: RuleEvaluationContext\n): { matched: boolean; failedConditions: RuleCondition[] } {\n  if (!rule.isActive) {\n    return { matched: false, failedConditions: rule.conditions };\n  }\n\n  const failedConditions: RuleCondition[] = [];\n\n  for (const condition of rule.conditions) {\n    if (!evaluateCondition(condition, context)) {\n      failedConditions.push(condition);\n    }\n  }\n\n  return {\n    matched: failedConditions.length === 0,\n    failedConditions,\n  };\n}\n\n/**\n * Evaluate all rules and return the first matching rule (by priority)\n */\nexport function evaluateRules(\n  rules: ApprovalRule[],\n  context: RuleEvaluationContext\n): RuleEvaluationResult {\n  // Sort rules by priority (lower number = higher priority)\n  const sortedRules = [...rules].sort((a, b) => a.priority - b.priority);\n\n  const evaluations: RuleEvaluationResult[\"evaluations\"] = [];\n  let matchedRule: ApprovalRule | undefined;\n\n  for (const rule of sortedRules) {\n    const { matched, failedConditions } = evaluateRule(rule, context);\n\n    evaluations.push({\n      rule,\n      matched,\n      failedConditions,\n    });\n\n    if (matched && !matchedRule) {\n      matchedRule = rule;\n      // Continue evaluating remaining rules for completeness\n    }\n  }\n\n  const result: RuleEvaluationResult = {\n    matched: matchedRule !== undefined,\n    evaluations,\n  };\n\n  if (matchedRule) {\n    result.matchedRule = matchedRule;\n    result.action = matchedRule.action;\n  }\n\n  return result;\n}\n\n/**\n * Get required approvers based on rule evaluation result\n */\nexport function getRequiredApprovers(result: RuleEvaluationResult): string[] {\n  if (!result.matched || !result.action) {\n    return [];\n  }\n\n  switch (result.action.type) {\n    case \"require_approval\":\n    case \"require_multi_approval\":\n      return result.action.approverIds ?? [];\n\n    case \"escalate\":\n      return result.action.escalateTo ? [result.action.escalateTo] : [];\n\n    default:\n      return [];\n  }\n}\n\n/**\n * Check if approval is required based on rules\n */\nexport function requiresApproval(result: RuleEvaluationResult): boolean {\n  if (!result.matched || !result.action) {\n    // Default: require approval if no rule matches\n    return true;\n  }\n\n  return (\n    result.action.type === \"require_approval\" ||\n    result.action.type === \"require_multi_approval\" ||\n    result.action.type === \"escalate\"\n  );\n}\n\n/**\n * Check if auto-approval is allowed based on rules\n */\nexport function canAutoApprove(result: RuleEvaluationResult): boolean {\n  return result.matched && result.action?.type === \"auto_approve\";\n}\n\n/**\n * Check if request should be rejected based on rules\n */\nexport function shouldReject(result: RuleEvaluationResult): boolean {\n  return result.matched && result.action?.type === \"reject\";\n}\n\n/**\n * Create a simple amount-based approval rule\n */\nexport function createAmountRule(\n  id: string,\n  name: string,\n  threshold: number,\n  action: RuleAction,\n  priority: number = 100\n): ApprovalRule {\n  return {\n    id,\n    name,\n    conditions: [\n      {\n        type: \"amount_greater_than\",\n        value: threshold,\n      },\n    ],\n    action,\n    priority,\n    isActive: true,\n  };\n}\n\n/**\n * Create a role-based approval rule\n */\nexport function createRoleRule(\n  id: string,\n  name: string,\n  roles: string[],\n  action: RuleAction,\n  priority: number = 100\n): ApprovalRule {\n  return {\n    id,\n    name,\n    conditions: [\n      {\n        type: \"user_role_in\",\n        value: roles,\n      },\n    ],\n    action,\n    priority,\n    isActive: true,\n  };\n}\n\n/**\n * Create a department-based approval rule\n */\nexport function createDepartmentRule(\n  id: string,\n  name: string,\n  departments: string[],\n  action: RuleAction,\n  priority: number = 100\n): ApprovalRule {\n  return {\n    id,\n    name,\n    conditions: [\n      {\n        type: \"department_in\",\n        value: departments,\n      },\n    ],\n    action,\n    priority,\n    isActive: true,\n  };\n}\n\n/**\n * Default approval rules for B2B\n */\nexport const DEFAULT_APPROVAL_RULES: ApprovalRule[] = [\n  {\n    id: \"auto-approve-small\",\n    name: \"Auto-approve small orders\",\n    description: \"Automatically approve orders under 500\",\n    conditions: [{ type: \"amount_less_than\", value: 500 }],\n    action: { type: \"auto_approve\" },\n    priority: 10,\n    isActive: true,\n  },\n  {\n    id: \"manager-approval-medium\",\n    name: \"Manager approval for medium orders\",\n    description: \"Require manager approval for orders 500-5000\",\n    conditions: [{ type: \"amount_between\", value: 500, valueTo: 5000 }],\n    action: {\n      type: \"require_approval\",\n      approverIds: [], // To be filled with manager IDs\n    },\n    priority: 20,\n    isActive: true,\n  },\n  {\n    id: \"executive-approval-large\",\n    name: \"Executive approval for large orders\",\n    description: \"Require executive approval for orders over 5000\",\n    conditions: [{ type: \"amount_greater_than\", value: 5000 }],\n    action: {\n      type: \"require_multi_approval\",\n      approverIds: [], // To be filled with executive IDs\n      requiredApprovals: 2,\n    },\n    priority: 30,\n    isActive: true,\n  },\n];\n","/**\n * Spending Calculator Utilities\n *\n * Functions for calculating spending limits, usage, and projections.\n */\n\n/**\n * Spending period type\n */\nexport type SpendingPeriodType =\n  | \"daily\"\n  | \"weekly\"\n  | \"monthly\"\n  | \"quarterly\"\n  | \"yearly\";\n\n/**\n * Spending record\n */\nexport interface SpendingRecord {\n  amount: number;\n  date: Date;\n  category?: string;\n  reference?: string;\n}\n\n/**\n * Spending limit configuration\n */\nexport interface SpendingLimitConfig {\n  maxAmount: number;\n  period: SpendingPeriodType;\n  softLimitPercentage?: number; // e.g., 75 for 75%\n  hardLimitPercentage?: number; // e.g., 100 for 100%\n  rollover?: boolean; // Whether unused amount rolls over\n  rolloverPercentage?: number; // Max percentage to roll over\n}\n\n/**\n * Spending calculation result\n */\nexport interface SpendingCalculation {\n  /** Total spent in current period */\n  totalSpent: number;\n  /** Remaining amount */\n  remaining: number;\n  /** Usage percentage */\n  percentage: number;\n  /** Whether soft limit is exceeded */\n  softLimitExceeded: boolean;\n  /** Whether hard limit is exceeded */\n  hardLimitExceeded: boolean;\n  /** Period start date */\n  periodStart: Date;\n  /** Period end date */\n  periodEnd: Date;\n  /** Days remaining in period */\n  daysRemaining: number;\n  /** Average daily spending */\n  averageDaily: number;\n  /** Projected end-of-period spending */\n  projected: number;\n  /** Whether on track to stay under limit */\n  onTrack: boolean;\n  /** Recommended daily budget to stay under limit */\n  recommendedDaily: number;\n}\n\n/**\n * Get period start and end dates\n */\nexport function getPeriodDates(\n  period: SpendingPeriodType,\n  referenceDate: Date = new Date()\n): { start: Date; end: Date } {\n  const date = new Date(referenceDate);\n\n  switch (period) {\n    case \"daily\": {\n      const start = new Date(date);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setDate(end.getDate() + 1);\n      end.setMilliseconds(-1);\n      return { start, end };\n    }\n\n    case \"weekly\": {\n      const start = new Date(date);\n      const day = start.getDay();\n      const diff = start.getDate() - day + (day === 0 ? -6 : 1); // Monday\n      start.setDate(diff);\n      start.setHours(0, 0, 0, 0);\n      const end = new Date(start);\n      end.setDate(end.getDate() + 7);\n      end.setMilliseconds(-1);\n      return { start, end };\n    }\n\n    case \"monthly\": {\n      const start = new Date(date.getFullYear(), date.getMonth(), 1);\n      const end = new Date(date.getFullYear(), date.getMonth() + 1, 0, 23, 59, 59, 999);\n      return { start, end };\n    }\n\n    case \"quarterly\": {\n      const quarter = Math.floor(date.getMonth() / 3);\n      const start = new Date(date.getFullYear(), quarter * 3, 1);\n      const end = new Date(date.getFullYear(), quarter * 3 + 3, 0, 23, 59, 59, 999);\n      return { start, end };\n    }\n\n    case \"yearly\": {\n      const start = new Date(date.getFullYear(), 0, 1);\n      const end = new Date(date.getFullYear(), 11, 31, 23, 59, 59, 999);\n      return { start, end };\n    }\n\n    default:\n      throw new Error(`Unknown period type: ${period}`);\n  }\n}\n\n/**\n * Calculate days between two dates\n */\nexport function daysBetween(start: Date, end: Date): number {\n  const msPerDay = 24 * 60 * 60 * 1000;\n  return Math.ceil((end.getTime() - start.getTime()) / msPerDay);\n}\n\n/**\n * Filter spending records by date range\n */\nexport function filterByPeriod(\n  records: SpendingRecord[],\n  start: Date,\n  end: Date\n): SpendingRecord[] {\n  return records.filter(\n    (record) => record.date >= start && record.date <= end\n  );\n}\n\n/**\n * Calculate total spending from records\n */\nexport function calculateTotal(records: SpendingRecord[]): number {\n  return records.reduce((sum, record) => sum + record.amount, 0);\n}\n\n/**\n * Calculate spending by category\n */\nexport function calculateByCategory(\n  records: SpendingRecord[]\n): Record<string, number> {\n  const byCategory: Record<string, number> = {};\n\n  for (const record of records) {\n    const category = record.category ?? \"uncategorized\";\n    byCategory[category] = (byCategory[category] ?? 0) + record.amount;\n  }\n\n  return byCategory;\n}\n\n/**\n * Calculate spending by day\n */\nexport function calculateByDay(\n  records: SpendingRecord[]\n): Record<string, number> {\n  const byDay: Record<string, number> = {};\n\n  for (const record of records) {\n    const isoString = record.date.toISOString();\n    const day = isoString.split(\"T\")[0] ?? isoString.substring(0, 10);\n    byDay[day] = (byDay[day] ?? 0) + record.amount;\n  }\n\n  return byDay;\n}\n\n/**\n * Calculate complete spending metrics\n */\nexport function calculateSpending(\n  records: SpendingRecord[],\n  config: SpendingLimitConfig,\n  referenceDate: Date = new Date()\n): SpendingCalculation {\n  const { start: periodStart, end: periodEnd } = getPeriodDates(\n    config.period,\n    referenceDate\n  );\n\n  // Filter records for current period\n  const periodRecords = filterByPeriod(records, periodStart, periodEnd);\n  const totalSpent = calculateTotal(periodRecords);\n\n  // Calculate remaining\n  const remaining = Math.max(0, config.maxAmount - totalSpent);\n\n  // Calculate percentage\n  const percentage =\n    config.maxAmount > 0 ? (totalSpent / config.maxAmount) * 100 : 0;\n\n  // Check limits\n  const softLimitPercentage = config.softLimitPercentage ?? 75;\n  const hardLimitPercentage = config.hardLimitPercentage ?? 100;\n  const softLimitExceeded = percentage >= softLimitPercentage;\n  const hardLimitExceeded = percentage >= hardLimitPercentage;\n\n  // Calculate days\n  const now = new Date(referenceDate);\n  const daysInPeriod = daysBetween(periodStart, periodEnd);\n  const daysElapsed = Math.max(1, daysBetween(periodStart, now));\n  const daysRemaining = Math.max(0, daysBetween(now, periodEnd));\n\n  // Calculate averages and projections\n  const averageDaily = totalSpent / daysElapsed;\n  const projected = averageDaily * daysInPeriod;\n  const onTrack = projected <= config.maxAmount;\n\n  // Calculate recommended daily budget\n  const recommendedDaily =\n    daysRemaining > 0 ? remaining / daysRemaining : 0;\n\n  return {\n    totalSpent,\n    remaining,\n    percentage,\n    softLimitExceeded,\n    hardLimitExceeded,\n    periodStart,\n    periodEnd,\n    daysRemaining,\n    averageDaily,\n    projected,\n    onTrack,\n    recommendedDaily,\n  };\n}\n\n/**\n * Calculate rollover amount from previous period\n */\nexport function calculateRollover(\n  previousPeriodSpent: number,\n  config: SpendingLimitConfig\n): number {\n  if (!config.rollover) return 0;\n\n  const unused = Math.max(0, config.maxAmount - previousPeriodSpent);\n  const rolloverPercentage = config.rolloverPercentage ?? 100;\n\n  return unused * (rolloverPercentage / 100);\n}\n\n/**\n * Calculate effective limit including rollover\n */\nexport function calculateEffectiveLimit(\n  config: SpendingLimitConfig,\n  rolloverAmount: number = 0\n): number {\n  return config.maxAmount + rolloverAmount;\n}\n\n/**\n * Check if a purchase can be made within limit\n */\nexport function canMakePurchase(\n  purchaseAmount: number,\n  currentSpent: number,\n  limit: number,\n  allowExceed: boolean = false\n): { allowed: boolean; reason?: string } {\n  if (allowExceed) {\n    return { allowed: true };\n  }\n\n  const newTotal = currentSpent + purchaseAmount;\n\n  if (newTotal > limit) {\n    return {\n      allowed: false,\n      reason: `Purchase would exceed spending limit. Current: ${currentSpent}, Purchase: ${purchaseAmount}, Limit: ${limit}`,\n    };\n  }\n\n  return { allowed: true };\n}\n\n/**\n * Calculate spending trend\n */\nexport function calculateTrend(\n  currentPeriodSpent: number,\n  previousPeriodSpent: number\n): { direction: \"up\" | \"down\" | \"stable\"; percentage: number } {\n  if (previousPeriodSpent === 0) {\n    return {\n      direction: currentPeriodSpent > 0 ? \"up\" : \"stable\",\n      percentage: currentPeriodSpent > 0 ? 100 : 0,\n    };\n  }\n\n  const change =\n    ((currentPeriodSpent - previousPeriodSpent) / previousPeriodSpent) * 100;\n\n  let direction: \"up\" | \"down\" | \"stable\";\n  if (Math.abs(change) < 1) {\n    direction = \"stable\";\n  } else if (change > 0) {\n    direction = \"up\";\n  } else {\n    direction = \"down\";\n  }\n\n  return {\n    direction,\n    percentage: Math.abs(change),\n  };\n}\n\n/**\n * Generate spending forecast\n */\nexport function generateForecast(\n  records: SpendingRecord[],\n  config: SpendingLimitConfig,\n  forecastDays: number = 30\n): Array<{ date: Date; projected: number; limit: number }> {\n  const { start: periodStart } = getPeriodDates(config.period);\n  const periodRecords = filterByPeriod(\n    records,\n    periodStart,\n    new Date()\n  );\n\n  const byDay = calculateByDay(periodRecords);\n  const days = Object.keys(byDay);\n\n  // Calculate average daily spending\n  const total = calculateTotal(periodRecords);\n  const avgDaily = days.length > 0 ? total / days.length : 0;\n\n  // Generate forecast\n  const forecast: Array<{ date: Date; projected: number; limit: number }> = [];\n  let cumulative = total;\n\n  for (let i = 1; i <= forecastDays; i++) {\n    const date = new Date();\n    date.setDate(date.getDate() + i);\n    cumulative += avgDaily;\n\n    forecast.push({\n      date,\n      projected: cumulative,\n      limit: config.maxAmount,\n    });\n  }\n\n  return forecast;\n}\n\n/**\n * Calculate savings opportunity\n */\nexport function calculateSavingsOpportunity(\n  records: SpendingRecord[],\n  targetPercentage: number = 10\n): { potentialSavings: number; suggestions: string[] } {\n  const byCategory = calculateByCategory(records);\n  const total = calculateTotal(records);\n  const targetSavings = total * (targetPercentage / 100);\n\n  const suggestions: string[] = [];\n  let potentialSavings = 0;\n\n  // Sort categories by spending (highest first)\n  const sortedCategories = Object.entries(byCategory).sort(\n    ([, a], [, b]) => b - a\n  );\n\n  for (const [category, amount] of sortedCategories) {\n    const categoryPercentage = (amount / total) * 100;\n    if (categoryPercentage > 20) {\n      const savingAmount = amount * 0.1; // 10% reduction suggestion\n      potentialSavings += savingAmount;\n      suggestions.push(\n        `Reduce \"${category}\" spending by 10% to save ${savingAmount.toFixed(2)}`\n      );\n    }\n\n    if (potentialSavings >= targetSavings) break;\n  }\n\n  return {\n    potentialSavings,\n    suggestions,\n  };\n}\n","/**\n * CSV Parser Utilities\n *\n * Functions for parsing and validating CSV data for bulk imports.\n */\n\n/**\n * CSV parsing options\n */\nexport interface CsvParseOptions {\n  /** Field delimiter (default: ',') */\n  delimiter?: string;\n  /** Whether first row is header (default: true) */\n  hasHeader?: boolean;\n  /** Quote character (default: '\"') */\n  quote?: string;\n  /** Whether to trim whitespace from values (default: true) */\n  trim?: boolean;\n  /** Whether to skip empty lines (default: true) */\n  skipEmptyLines?: boolean;\n  /** Maximum number of rows to parse (0 = unlimited) */\n  maxRows?: number;\n  /** Expected column names (for validation) */\n  expectedColumns?: string[];\n  /** Required column names (must be present) */\n  requiredColumns?: string[];\n}\n\n/**\n * CSV parse result\n */\nexport interface CsvParseResult<T = Record<string, string>> {\n  /** Parsed data rows */\n  data: T[];\n  /** Column headers */\n  headers: string[];\n  /** Total rows parsed (including header) */\n  totalRows: number;\n  /** Errors encountered during parsing */\n  errors: CsvParseError[];\n  /** Whether parsing was successful */\n  success: boolean;\n  /** Raw parsed rows (before type conversion) */\n  rawRows: string[][];\n}\n\n/**\n * CSV parse error\n */\nexport interface CsvParseError {\n  /** Row number (1-indexed) */\n  row: number;\n  /** Column number (1-indexed) */\n  column?: number;\n  /** Column name */\n  columnName?: string;\n  /** Error message */\n  message: string;\n  /** Error type */\n  type: \"parse\" | \"validation\" | \"missing_required\" | \"invalid_value\";\n  /** Raw value that caused the error */\n  value?: string;\n}\n\n/**\n * Column mapping configuration\n */\nexport interface ColumnMapping {\n  /** Source column name (from CSV) */\n  source: string;\n  /** Target field name */\n  target: string;\n  /** Whether column is required */\n  required?: boolean;\n  /** Default value if empty */\n  defaultValue?: unknown;\n  /** Transform function */\n  transform?: (value: string) => unknown;\n  /** Validation function */\n  validate?: (value: string) => boolean | string;\n}\n\n/**\n * Parse a CSV line respecting quotes\n */\nfunction parseLine(\n  line: string,\n  delimiter: string,\n  quote: string\n): string[] {\n  const result: string[] = [];\n  let current = \"\";\n  let inQuotes = false;\n  let i = 0;\n\n  while (i < line.length) {\n    const char = line[i];\n\n    if (char === quote) {\n      if (inQuotes && line[i + 1] === quote) {\n        // Escaped quote\n        current += quote;\n        i += 2;\n        continue;\n      }\n      inQuotes = !inQuotes;\n      i++;\n      continue;\n    }\n\n    if (char === delimiter && !inQuotes) {\n      result.push(current);\n      current = \"\";\n      i++;\n      continue;\n    }\n\n    current += char;\n    i++;\n  }\n\n  result.push(current);\n  return result;\n}\n\n/**\n * Parse CSV string into rows and columns\n */\nexport function parseCsv<T = Record<string, string>>(\n  csvString: string,\n  options: CsvParseOptions = {}\n): CsvParseResult<T> {\n  const {\n    delimiter = \",\",\n    hasHeader = true,\n    quote = '\"',\n    trim = true,\n    skipEmptyLines = true,\n    maxRows = 0,\n    expectedColumns,\n    requiredColumns,\n  } = options;\n\n  const errors: CsvParseError[] = [];\n  const rawRows: string[][] = [];\n\n  // Split into lines\n  const lines = csvString.split(/\\r?\\n/);\n\n  // Parse each line\n  let rowIndex = 0;\n  for (const line of lines) {\n    // Skip empty lines\n    if (skipEmptyLines && line.trim() === \"\") {\n      continue;\n    }\n\n    // Check max rows\n    if (maxRows > 0 && rowIndex >= maxRows) {\n      break;\n    }\n\n    try {\n      let values = parseLine(line, delimiter, quote);\n\n      if (trim) {\n        values = values.map((v) => v.trim());\n      }\n\n      rawRows.push(values);\n      rowIndex++;\n    } catch {\n      errors.push({\n        row: rowIndex + 1,\n        message: `Failed to parse line: ${line.substring(0, 50)}...`,\n        type: \"parse\",\n      });\n      rowIndex++;\n    }\n  }\n\n  if (rawRows.length === 0) {\n    return {\n      data: [],\n      headers: [],\n      totalRows: 0,\n      errors: [{ row: 0, message: \"Empty CSV file\", type: \"parse\" }],\n      success: false,\n      rawRows: [],\n    };\n  }\n\n  // Extract headers\n  const firstRow = rawRows[0];\n  if (!firstRow) {\n    return {\n      data: [],\n      headers: [],\n      totalRows: 0,\n      errors: [{ row: 0, message: \"No data rows found\", type: \"parse\" }],\n      success: false,\n      rawRows: [],\n    };\n  }\n  const headers: string[] = hasHeader ? firstRow : firstRow.map((_, i) => `column_${i + 1}`);\n  const dataRows = hasHeader ? rawRows.slice(1) : rawRows;\n\n  // Validate expected columns\n  if (expectedColumns) {\n    const missingColumns = expectedColumns.filter(\n      (col) => !headers.includes(col)\n    );\n    if (missingColumns.length > 0) {\n      errors.push({\n        row: 1,\n        message: `Missing expected columns: ${missingColumns.join(\", \")}`,\n        type: \"validation\",\n      });\n    }\n  }\n\n  // Validate required columns\n  if (requiredColumns) {\n    const missingRequired = requiredColumns.filter(\n      (col) => !headers.includes(col)\n    );\n    if (missingRequired.length > 0) {\n      errors.push({\n        row: 1,\n        message: `Missing required columns: ${missingRequired.join(\", \")}`,\n        type: \"missing_required\",\n      });\n    }\n  }\n\n  // Convert to objects\n  const data: T[] = dataRows.map((row, index) => {\n    const obj: Record<string, string> = {};\n    headers.forEach((header, colIndex) => {\n      obj[header] = row[colIndex] ?? \"\";\n    });\n    return obj as T;\n  });\n\n  return {\n    data,\n    headers,\n    totalRows: rawRows.length,\n    errors,\n    success: errors.filter((e) => e.type !== \"validation\").length === 0,\n    rawRows,\n  };\n}\n\n/**\n * Map CSV columns to target fields\n */\nexport function mapColumns<T>(\n  data: Record<string, string>[],\n  mappings: ColumnMapping[]\n): { data: T[]; errors: CsvParseError[] } {\n  const errors: CsvParseError[] = [];\n  const result: T[] = [];\n\n  data.forEach((row, rowIndex) => {\n    const mapped: Record<string, unknown> = {};\n\n    for (const mapping of mappings) {\n      const rawValue = row[mapping.source];\n\n      // Check required\n      if (mapping.required && (rawValue === undefined || rawValue === \"\")) {\n        const error: CsvParseError = {\n          row: rowIndex + 2, // +2 for header and 0-indexing\n          columnName: mapping.source,\n          message: `Required field \"${mapping.source}\" is empty`,\n          type: \"missing_required\",\n        };\n        if (rawValue !== undefined) {\n          error.value = rawValue;\n        }\n        errors.push(error);\n        continue;\n      }\n\n      // Use default value if empty\n      if ((rawValue === undefined || rawValue === \"\") && mapping.defaultValue !== undefined) {\n        mapped[mapping.target] = mapping.defaultValue;\n        continue;\n      }\n\n      // Validate\n      if (mapping.validate && rawValue !== undefined && rawValue !== \"\") {\n        const validationResult = mapping.validate(rawValue);\n        if (validationResult !== true) {\n          errors.push({\n            row: rowIndex + 2,\n            columnName: mapping.source,\n            message:\n              typeof validationResult === \"string\"\n                ? validationResult\n                : `Invalid value for \"${mapping.source}\"`,\n            type: \"invalid_value\",\n            value: rawValue,\n          });\n          continue;\n        }\n      }\n\n      // Transform\n      if (mapping.transform && rawValue !== undefined) {\n        try {\n          mapped[mapping.target] = mapping.transform(rawValue);\n        } catch {\n          errors.push({\n            row: rowIndex + 2,\n            columnName: mapping.source,\n            message: `Failed to transform value for \"${mapping.source}\"`,\n            type: \"invalid_value\",\n            value: rawValue,\n          });\n        }\n      } else {\n        mapped[mapping.target] = rawValue;\n      }\n    }\n\n    result.push(mapped as T);\n  });\n\n  return { data: result, errors };\n}\n\n/**\n * Generate CSV string from data\n */\nexport function generateCsv<T extends Record<string, unknown>>(\n  data: T[],\n  options: {\n    columns?: string[];\n    delimiter?: string;\n    includeHeader?: boolean;\n    quote?: string;\n  } = {}\n): string {\n  const {\n    columns,\n    delimiter = \",\",\n    includeHeader = true,\n    quote = '\"',\n  } = options;\n\n  if (data.length === 0) {\n    return columns && includeHeader ? columns.join(delimiter) : \"\";\n  }\n\n  const firstDataRow = data[0];\n  const headers: string[] = columns ?? (firstDataRow ? Object.keys(firstDataRow) : []);\n\n  const escapeValue = (value: unknown): string => {\n    const str = String(value ?? \"\");\n    if (\n      str.includes(delimiter) ||\n      str.includes(quote) ||\n      str.includes(\"\\n\") ||\n      str.includes(\"\\r\")\n    ) {\n      return `${quote}${str.replace(new RegExp(quote, \"g\"), quote + quote)}${quote}`;\n    }\n    return str;\n  };\n\n  const lines: string[] = [];\n\n  if (includeHeader) {\n    lines.push(headers.map(escapeValue).join(delimiter));\n  }\n\n  for (const row of data) {\n    const values = headers.map((header) => escapeValue(row[header]));\n    lines.push(values.join(delimiter));\n  }\n\n  return lines.join(\"\\n\");\n}\n\n/**\n * Common column mappings for employee import\n */\nexport const EMPLOYEE_COLUMN_MAPPINGS: ColumnMapping[] = [\n  {\n    source: \"first_name\",\n    target: \"firstName\",\n    required: true,\n    validate: (v) => v.length > 0 || \"First name is required\",\n  },\n  {\n    source: \"last_name\",\n    target: \"lastName\",\n    required: true,\n    validate: (v) => v.length > 0 || \"Last name is required\",\n  },\n  {\n    source: \"email\",\n    target: \"email\",\n    required: true,\n    validate: (v) =>\n      /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(v) || \"Invalid email format\",\n  },\n  {\n    source: \"phone\",\n    target: \"phone\",\n    required: false,\n  },\n  {\n    source: \"role\",\n    target: \"role\",\n    required: false,\n    defaultValue: \"viewer\",\n    validate: (v) =>\n      [\"admin\", \"manager\", \"purchaser\", \"viewer\", \"approver\"].includes(v) ||\n      \"Invalid role\",\n  },\n  {\n    source: \"department\",\n    target: \"department\",\n    required: false,\n  },\n  {\n    source: \"job_title\",\n    target: \"jobTitle\",\n    required: false,\n  },\n  {\n    source: \"employee_number\",\n    target: \"employeeNumber\",\n    required: false,\n  },\n  {\n    source: \"monthly_limit\",\n    target: \"monthlyLimit\",\n    required: false,\n    transform: (v) => (v ? parseFloat(v) : undefined),\n    validate: (v) => !v || !isNaN(parseFloat(v)) || \"Invalid number\",\n  },\n  {\n    source: \"order_limit\",\n    target: \"orderLimit\",\n    required: false,\n    transform: (v) => (v ? parseFloat(v) : undefined),\n    validate: (v) => !v || !isNaN(parseFloat(v)) || \"Invalid number\",\n  },\n  {\n    source: \"manager_id\",\n    target: \"managerId\",\n    required: false,\n  },\n];\n\n/**\n * Generate a sample CSV template\n */\nexport function generateTemplate(\n  mappings: ColumnMapping[],\n  sampleData?: Record<string, string>[]\n): string {\n  const headers = mappings.map((m) => m.source);\n\n  if (!sampleData || sampleData.length === 0) {\n    return headers.join(\",\");\n  }\n\n  return generateCsv(sampleData, { columns: headers });\n}\n\n/**\n * Validate CSV file size\n */\nexport function validateFileSize(\n  file: File | Blob,\n  maxSizeBytes: number = 10 * 1024 * 1024 // 10MB default\n): { valid: boolean; error?: string } {\n  if (file.size > maxSizeBytes) {\n    const maxSizeMB = (maxSizeBytes / (1024 * 1024)).toFixed(1);\n    const fileSizeMB = (file.size / (1024 * 1024)).toFixed(1);\n    return {\n      valid: false,\n      error: `File size (${fileSizeMB}MB) exceeds maximum allowed size (${maxSizeMB}MB)`,\n    };\n  }\n  return { valid: true };\n}\n\n/**\n * Read CSV file content as string (browser-compatible)\n *\n * Note: This function requires browser environment with FileReader API.\n * For Node.js, use fs.readFileSync and then parseCsv.\n *\n * @example\n * ```tsx\n * // Browser usage\n * const handleFileUpload = async (file: File) => {\n *   const text = await readFileAsText(file);\n *   const result = parseCsv(text, { requiredColumns: ['email', 'name'] });\n *   return result;\n * };\n * ```\n */\nexport function readFileAsText(file: Blob): Promise<string> {\n  return new Promise((resolve, reject) => {\n    if (typeof FileReader === \"undefined\") {\n      reject(new Error(\"FileReader is not available in this environment\"));\n      return;\n    }\n\n    const reader = new FileReader();\n\n    reader.onload = (event: ProgressEvent<FileReader>) => {\n      const result = event.target?.result;\n      if (typeof result === \"string\") {\n        resolve(result);\n      } else {\n        reject(new Error(\"Failed to read file as text\"));\n      }\n    };\n\n    reader.onerror = () => {\n      reject(new Error(\"Failed to read file\"));\n    };\n\n    reader.readAsText(file);\n  });\n}\n\n/**\n * Read and parse CSV file (browser-compatible)\n *\n * Combines file reading and parsing in one operation.\n *\n * @example\n * ```tsx\n * const handleFileUpload = async (file: File) => {\n *   const result = await readAndParseCsv(file, {\n *     requiredColumns: ['email', 'name'],\n *   });\n *   if (result.success) {\n *     console.log('Parsed rows:', result.data);\n *   }\n * };\n * ```\n */\nexport async function readAndParseCsv<T = Record<string, string>>(\n  file: Blob,\n  options: CsvParseOptions = {}\n): Promise<CsvParseResult<T>> {\n  const text = await readFileAsText(file);\n  return parseCsv<T>(text, options);\n}\n","/**\n * B2B-specific Formatting Utilities\n *\n * Functions for formatting currencies, dates, numbers,\n * and other B2B-specific data.\n */\n\n/**\n * Currency configuration\n */\nexport interface CurrencyFormatOptions {\n  /** Currency code (e.g., 'EUR', 'USD') */\n  code?: string;\n  /** Locale for formatting */\n  locale?: string;\n  /** Minimum fraction digits */\n  minimumFractionDigits?: number;\n  /** Maximum fraction digits */\n  maximumFractionDigits?: number;\n  /** Whether to show currency symbol */\n  showSymbol?: boolean;\n  /** Whether to show currency code */\n  showCode?: boolean;\n}\n\n/**\n * Date format options\n */\nexport interface DateFormatOptions {\n  /** Date format style */\n  style?: \"short\" | \"medium\" | \"long\" | \"full\";\n  /** Include time */\n  includeTime?: boolean;\n  /** Time style */\n  timeStyle?: \"short\" | \"medium\" | \"long\";\n  /** Locale for formatting */\n  locale?: string;\n  /** Custom format pattern */\n  pattern?: string;\n}\n\n/**\n * Number format options\n */\nexport interface NumberFormatOptions {\n  /** Locale for formatting */\n  locale?: string;\n  /** Minimum fraction digits */\n  minimumFractionDigits?: number;\n  /** Maximum fraction digits */\n  maximumFractionDigits?: number;\n  /** Use grouping separators */\n  useGrouping?: boolean;\n  /** Notation style */\n  notation?: \"standard\" | \"scientific\" | \"engineering\" | \"compact\";\n  /** Compact display */\n  compactDisplay?: \"short\" | \"long\";\n}\n\n// Default locale\nconst DEFAULT_LOCALE = \"fr-FR\";\n\n/**\n * Format currency amount\n */\nexport function formatCurrency(\n  amount: number,\n  options: CurrencyFormatOptions = {}\n): string {\n  const {\n    code = \"EUR\",\n    locale = DEFAULT_LOCALE,\n    minimumFractionDigits = 2,\n    maximumFractionDigits = 2,\n    showSymbol = true,\n    showCode = false,\n  } = options;\n\n  if (showSymbol) {\n    const formatter = new Intl.NumberFormat(locale, {\n      style: \"currency\",\n      currency: code,\n      minimumFractionDigits,\n      maximumFractionDigits,\n    });\n    return formatter.format(amount);\n  }\n\n  const formatter = new Intl.NumberFormat(locale, {\n    minimumFractionDigits,\n    maximumFractionDigits,\n  });\n\n  const formatted = formatter.format(amount);\n  return showCode ? `${formatted} ${code}` : formatted;\n}\n\n/**\n * Format currency with abbreviated large numbers\n */\nexport function formatCurrencyCompact(\n  amount: number,\n  options: CurrencyFormatOptions = {}\n): string {\n  const { code = \"EUR\", locale = DEFAULT_LOCALE } = options;\n\n  const formatter = new Intl.NumberFormat(locale, {\n    style: \"currency\",\n    currency: code,\n    notation: \"compact\",\n    compactDisplay: \"short\",\n    maximumFractionDigits: 1,\n  });\n\n  return formatter.format(amount);\n}\n\n/**\n * Format date\n */\nexport function formatDate(\n  date: Date | string | number,\n  options: DateFormatOptions = {}\n): string {\n  const {\n    style = \"medium\",\n    includeTime = false,\n    timeStyle = \"short\",\n    locale = DEFAULT_LOCALE,\n  } = options;\n\n  const dateObj = date instanceof Date ? date : new Date(date);\n\n  if (isNaN(dateObj.getTime())) {\n    return \"Invalid date\";\n  }\n\n  const dateStyleMap: Record<string, Intl.DateTimeFormatOptions[\"dateStyle\"]> = {\n    short: \"short\",\n    medium: \"medium\",\n    long: \"long\",\n    full: \"full\",\n  };\n\n  const timeStyleMap: Record<string, Intl.DateTimeFormatOptions[\"timeStyle\"]> = {\n    short: \"short\",\n    medium: \"medium\",\n    long: \"long\",\n  };\n\n  const formatOptions: Intl.DateTimeFormatOptions = {\n    dateStyle: dateStyleMap[style],\n  };\n\n  if (includeTime) {\n    formatOptions.timeStyle = timeStyleMap[timeStyle];\n  }\n\n  return new Intl.DateTimeFormat(locale, formatOptions).format(dateObj);\n}\n\n/**\n * Format relative date (e.g., \"2 days ago\", \"in 3 hours\")\n */\nexport function formatRelativeDate(\n  date: Date | string | number,\n  locale: string = DEFAULT_LOCALE\n): string {\n  const dateObj = date instanceof Date ? date : new Date(date);\n  const now = new Date();\n  const diffMs = dateObj.getTime() - now.getTime();\n  const diffSeconds = Math.round(diffMs / 1000);\n  const diffMinutes = Math.round(diffSeconds / 60);\n  const diffHours = Math.round(diffMinutes / 60);\n  const diffDays = Math.round(diffHours / 24);\n  const diffWeeks = Math.round(diffDays / 7);\n  const diffMonths = Math.round(diffDays / 30);\n  const diffYears = Math.round(diffDays / 365);\n\n  const rtf = new Intl.RelativeTimeFormat(locale, { numeric: \"auto\" });\n\n  if (Math.abs(diffSeconds) < 60) {\n    return rtf.format(diffSeconds, \"second\");\n  }\n  if (Math.abs(diffMinutes) < 60) {\n    return rtf.format(diffMinutes, \"minute\");\n  }\n  if (Math.abs(diffHours) < 24) {\n    return rtf.format(diffHours, \"hour\");\n  }\n  if (Math.abs(diffDays) < 7) {\n    return rtf.format(diffDays, \"day\");\n  }\n  if (Math.abs(diffWeeks) < 4) {\n    return rtf.format(diffWeeks, \"week\");\n  }\n  if (Math.abs(diffMonths) < 12) {\n    return rtf.format(diffMonths, \"month\");\n  }\n  return rtf.format(diffYears, \"year\");\n}\n\n/**\n * Format number\n */\nexport function formatNumber(\n  value: number,\n  options: NumberFormatOptions = {}\n): string {\n  const {\n    locale = DEFAULT_LOCALE,\n    minimumFractionDigits,\n    maximumFractionDigits,\n    useGrouping = true,\n    notation = \"standard\",\n    compactDisplay = \"short\",\n  } = options;\n\n  const formatter = new Intl.NumberFormat(locale, {\n    minimumFractionDigits,\n    maximumFractionDigits,\n    useGrouping,\n    notation,\n    compactDisplay: notation === \"compact\" ? compactDisplay : undefined,\n  });\n\n  return formatter.format(value);\n}\n\n/**\n * Format percentage\n */\nexport function formatPercentage(\n  value: number,\n  options: {\n    locale?: string;\n    minimumFractionDigits?: number;\n    maximumFractionDigits?: number;\n    showSign?: boolean;\n  } = {}\n): string {\n  const {\n    locale = DEFAULT_LOCALE,\n    minimumFractionDigits = 0,\n    maximumFractionDigits = 1,\n    showSign = false,\n  } = options;\n\n  const formatter = new Intl.NumberFormat(locale, {\n    style: \"percent\",\n    minimumFractionDigits,\n    maximumFractionDigits,\n    signDisplay: showSign ? \"always\" : \"auto\",\n  });\n\n  // Intl.NumberFormat expects 0.5 for 50%, but we often pass 50\n  const normalizedValue = Math.abs(value) > 1 ? value / 100 : value;\n  return formatter.format(normalizedValue);\n}\n\n/**\n * Format order/quote number\n */\nexport function formatOrderNumber(\n  number: string | number,\n  prefix: string = \"ORD\"\n): string {\n  const numStr = String(number).padStart(6, \"0\");\n  return `${prefix}-${numStr}`;\n}\n\n/**\n * Format quote number\n */\nexport function formatQuoteNumber(\n  number: string | number,\n  prefix: string = \"QUO\"\n): string {\n  const numStr = String(number).padStart(6, \"0\");\n  return `${prefix}-${numStr}`;\n}\n\n/**\n * Format invoice number\n */\nexport function formatInvoiceNumber(\n  number: string | number,\n  prefix: string = \"INV\"\n): string {\n  const numStr = String(number).padStart(6, \"0\");\n  return `${prefix}-${numStr}`;\n}\n\n/**\n * Format phone number\n */\nexport function formatPhoneNumber(\n  phone: string,\n  countryCode: string = \"FR\"\n): string {\n  // Remove all non-numeric characters\n  const cleaned = phone.replace(/\\D/g, \"\");\n\n  // Format based on country\n  switch (countryCode) {\n    case \"FR\":\n      // French format: 01 23 45 67 89\n      if (cleaned.length === 10) {\n        return cleaned.replace(/(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/, \"$1 $2 $3 $4 $5\");\n      }\n      if (cleaned.length === 11 && cleaned.startsWith(\"33\")) {\n        return `+33 ${cleaned.slice(2).replace(/(\\d{1})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/, \"$1 $2 $3 $4 $5\")}`;\n      }\n      break;\n    case \"US\":\n      // US format: (123) 456-7890\n      if (cleaned.length === 10) {\n        return cleaned.replace(/(\\d{3})(\\d{3})(\\d{4})/, \"($1) $2-$3\");\n      }\n      break;\n  }\n\n  return phone; // Return original if no formatting matched\n}\n\n/**\n * Format address for display\n */\nexport function formatAddress(\n  address: {\n    line1?: string;\n    line2?: string;\n    city?: string;\n    state?: string;\n    postalCode?: string;\n    country?: string;\n  },\n  options: { multiline?: boolean; separator?: string } = {}\n): string {\n  const { multiline = false, separator = \", \" } = options;\n\n  const parts: string[] = [];\n\n  if (address.line1) parts.push(address.line1);\n  if (address.line2) parts.push(address.line2);\n\n  const cityParts: string[] = [];\n  if (address.city) cityParts.push(address.city);\n  if (address.state) cityParts.push(address.state);\n  if (address.postalCode) cityParts.push(address.postalCode);\n  if (cityParts.length > 0) parts.push(cityParts.join(\" \"));\n\n  if (address.country) parts.push(address.country);\n\n  return multiline ? parts.join(\"\\n\") : parts.join(separator);\n}\n\n/**\n * Format VAT/Tax ID\n */\nexport function formatVatId(vatId: string, countryCode: string = \"FR\"): string {\n  // Remove all whitespace\n  const cleaned = vatId.replace(/\\s/g, \"\");\n\n  switch (countryCode) {\n    case \"FR\":\n      // French VAT: FR XX XXXXXXXXX\n      if (cleaned.length === 13 && cleaned.startsWith(\"FR\")) {\n        return `FR ${cleaned.slice(2, 4)} ${cleaned.slice(4)}`;\n      }\n      break;\n    case \"DE\":\n      // German VAT: DE XXXXXXXXX\n      if (cleaned.length === 11 && cleaned.startsWith(\"DE\")) {\n        return `DE ${cleaned.slice(2)}`;\n      }\n      break;\n  }\n\n  return vatId;\n}\n\n/**\n * Format file size\n */\nexport function formatFileSize(bytes: number): string {\n  const units = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\"];\n  let unitIndex = 0;\n  let size = bytes;\n\n  while (size >= 1024 && unitIndex < units.length - 1) {\n    size /= 1024;\n    unitIndex++;\n  }\n\n  return `${size.toFixed(unitIndex === 0 ? 0 : 1)} ${units[unitIndex]}`;\n}\n\n/**\n * Format quantity with unit\n */\nexport function formatQuantity(\n  quantity: number,\n  unit?: string,\n  options: NumberFormatOptions = {}\n): string {\n  const formatted = formatNumber(quantity, {\n    ...options,\n    maximumFractionDigits: options.maximumFractionDigits ?? 0,\n  });\n\n  return unit ? `${formatted} ${unit}` : formatted;\n}\n\n/**\n * Format duration (in minutes)\n */\nexport function formatDuration(\n  minutes: number,\n  options: { short?: boolean } = {}\n): string {\n  const { short = false } = options;\n\n  const hours = Math.floor(minutes / 60);\n  const mins = minutes % 60;\n\n  if (short) {\n    if (hours > 0 && mins > 0) {\n      return `${hours}h ${mins}m`;\n    }\n    if (hours > 0) {\n      return `${hours}h`;\n    }\n    return `${mins}m`;\n  }\n\n  const parts: string[] = [];\n  if (hours > 0) {\n    parts.push(`${hours} ${hours === 1 ? \"hour\" : \"hours\"}`);\n  }\n  if (mins > 0 || parts.length === 0) {\n    parts.push(`${mins} ${mins === 1 ? \"minute\" : \"minutes\"}`);\n  }\n\n  return parts.join(\" \");\n}\n\n/**\n * Truncate text with ellipsis\n */\nexport function truncateText(\n  text: string,\n  maxLength: number,\n  options: { ellipsis?: string; wordBoundary?: boolean } = {}\n): string {\n  const { ellipsis = \"...\", wordBoundary = true } = options;\n\n  if (text.length <= maxLength) {\n    return text;\n  }\n\n  let truncated = text.slice(0, maxLength - ellipsis.length);\n\n  if (wordBoundary) {\n    const lastSpace = truncated.lastIndexOf(\" \");\n    if (lastSpace > maxLength * 0.5) {\n      truncated = truncated.slice(0, lastSpace);\n    }\n  }\n\n  return truncated.trim() + ellipsis;\n}\n\n/**\n * Format company name (capitalize appropriately)\n */\nexport function formatCompanyName(name: string): string {\n  // List of words that should remain lowercase\n  const lowercaseWords = new Set([\n    \"and\",\n    \"or\",\n    \"the\",\n    \"a\",\n    \"an\",\n    \"of\",\n    \"in\",\n    \"for\",\n    \"to\",\n    \"et\",\n    \"de\",\n    \"la\",\n    \"le\",\n    \"du\",\n    \"des\",\n  ]);\n\n  // List of words that should remain uppercase\n  const uppercaseWords = new Set([\n    \"sarl\",\n    \"sas\",\n    \"sa\",\n    \"eurl\",\n    \"sci\",\n    \"llc\",\n    \"inc\",\n    \"ltd\",\n    \"plc\",\n    \"gmbh\",\n    \"ag\",\n  ]);\n\n  return name\n    .toLowerCase()\n    .split(/\\s+/)\n    .map((word, index) => {\n      const lowerWord = word.toLowerCase();\n\n      if (uppercaseWords.has(lowerWord)) {\n        return word.toUpperCase();\n      }\n\n      if (index > 0 && lowercaseWords.has(lowerWord)) {\n        return lowerWord;\n      }\n\n      return word.charAt(0).toUpperCase() + word.slice(1);\n    })\n    .join(\" \");\n}\n\n/**\n * Format payment terms for display\n */\nexport function formatPaymentTerms(terms: string): string {\n  const termsMap: Record<string, string> = {\n    NET30: \"Net 30 days\",\n    NET60: \"Net 60 days\",\n    NET90: \"Net 90 days\",\n    DUE_ON_RECEIPT: \"Due on receipt\",\n    COD: \"Cash on delivery\",\n    PREPAID: \"Prepaid\",\n    \"2/10_NET30\": \"2% 10, Net 30\",\n  };\n\n  return termsMap[terms] ?? terms;\n}\n"],"mappings":"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","names":["formatter"]}