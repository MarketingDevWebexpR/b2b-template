{"version":3,"sources":["../../src/api/index.ts","../../src/api/QueryCacheContext.tsx","../../src/api/useApiQuery.ts","../../src/api/useApiMutation.ts"],"sourcesContent":["/**\n * API Hooks\n *\n * Generic hooks for fetching and mutating data.\n */\n\n// Query Cache Context (SSR-safe)\nexport {\n  QueryCacheProvider,\n  useQueryCache,\n  useInvalidateQueries,\n  type QueryCacheContextValue,\n  type QueryCacheProviderProps,\n  type CacheEntry,\n  type UseInvalidateQueriesResult,\n} from \"./QueryCacheContext\";\n\n// Query Hook\nexport {\n  useApiQuery,\n  clearQueryCache,\n  invalidateQueries,\n  type QueryFnContext,\n  type QueryState,\n  type UseApiQueryOptions,\n  type UseApiQueryResult,\n} from \"./useApiQuery\";\n\n// Mutation Hook\nexport {\n  useApiMutation,\n  type MutationState,\n  type UseApiMutationOptions,\n  type UseApiMutationResult,\n} from \"./useApiMutation\";\n","/**\n * Query Cache Context\n *\n * Provides SSR-safe request-scoped caching for API queries.\n * Prevents data leaking between requests in server-side rendering environments.\n */\n\nimport React, {\n  createContext,\n  useContext,\n  useRef,\n  useMemo,\n  useCallback,\n  type ReactNode,\n} from \"react\";\n\n/**\n * Cache entry structure\n */\nexport interface CacheEntry<T = unknown> {\n  data: T;\n  timestamp: number;\n}\n\n/**\n * Query cache context value\n */\nexport interface QueryCacheContextValue {\n  /** Get data from cache if not stale */\n  getFromCache: <T,>(key: string, staleTime: number) => T | null;\n  /** Check if cache entry exists and is within cache time */\n  hasValidCache: (key: string, cacheTime: number) => boolean;\n  /** Get cached data regardless of staleness */\n  getCachedData: <T,>(key: string) => T | null;\n  /** Store data in cache */\n  setInCache: <T,>(key: string, data: T) => void;\n  /** Invalidate a specific cache key */\n  invalidate: (key: string) => void;\n  /** Invalidate all cache entries matching a prefix */\n  invalidateByPrefix: (prefix: string) => void;\n  /** Clear all cache entries */\n  invalidateAll: () => void;\n}\n\nconst QueryCacheContext = createContext<QueryCacheContextValue | null>(null);\n\n/**\n * Client-side fallback cache (only used when provider is not mounted)\n * This is safe because it's only used on the client side\n */\nlet clientFallbackCache: Map<string, CacheEntry> | null = null;\n\nfunction getClientFallbackCache(): Map<string, CacheEntry> {\n  if (!clientFallbackCache) {\n    clientFallbackCache = new Map();\n  }\n  return clientFallbackCache;\n}\n\n/**\n * Create cache operations for a given Map instance\n */\nfunction createCacheOperations(\n  cacheRef: React.MutableRefObject<Map<string, CacheEntry>>\n): QueryCacheContextValue {\n  const getFromCache = function <T,>(key: string, staleTime: number): T | null {\n    const cached = cacheRef.current.get(key);\n    if (cached && Date.now() - cached.timestamp < staleTime) {\n      return cached.data as T;\n    }\n    return null;\n  };\n\n  const hasValidCache = function (key: string, cacheTime: number): boolean {\n    const cached = cacheRef.current.get(key);\n    return cached !== undefined && Date.now() - cached.timestamp < cacheTime;\n  };\n\n  const getCachedData = function <T,>(key: string): T | null {\n    const cached = cacheRef.current.get(key);\n    return cached ? (cached.data as T) : null;\n  };\n\n  const setInCache = function <T,>(key: string, data: T): void {\n    cacheRef.current.set(key, { data, timestamp: Date.now() });\n  };\n\n  const invalidate = function (key: string): void {\n    cacheRef.current.delete(key);\n  };\n\n  const invalidateByPrefix = function (prefix: string): void {\n    const keysToDelete: string[] = [];\n    cacheRef.current.forEach((_, key) => {\n      if (key.startsWith(prefix)) {\n        keysToDelete.push(key);\n      }\n    });\n    keysToDelete.forEach((key) => cacheRef.current.delete(key));\n  };\n\n  const invalidateAll = function (): void {\n    cacheRef.current.clear();\n  };\n\n  return {\n    getFromCache,\n    hasValidCache,\n    getCachedData,\n    setInCache,\n    invalidate,\n    invalidateByPrefix,\n    invalidateAll,\n  };\n}\n\n/**\n * Props for QueryCacheProvider\n */\nexport interface QueryCacheProviderProps {\n  children: ReactNode;\n}\n\n/**\n * Query Cache Provider\n *\n * Wraps your application to provide request-scoped caching.\n * Must be used in SSR environments to prevent data leaking between requests.\n *\n * @example\n * ```tsx\n * // In your app layout or _app.tsx\n * import { QueryCacheProvider } from '@maison/hooks';\n *\n * export default function App({ children }) {\n *   return (\n *     <QueryCacheProvider>\n *       {children}\n *     </QueryCacheProvider>\n *   );\n * }\n * ```\n */\nexport function QueryCacheProvider({\n  children,\n}: QueryCacheProviderProps): React.ReactElement {\n  const cacheRef = useRef<Map<string, CacheEntry>>(new Map());\n\n  const value = useMemo<QueryCacheContextValue>(\n    () => createCacheOperations(cacheRef),\n    []\n  );\n\n  return (\n    <QueryCacheContext.Provider value={value}>\n      {children}\n    </QueryCacheContext.Provider>\n  );\n}\n\n/**\n * Hook to access the query cache\n *\n * Returns cache operations that are safe for SSR.\n * Falls back to a client-side cache if provider is not mounted (for testing or client-only apps).\n *\n * @throws Error if used in SSR without QueryCacheProvider\n *\n * @example\n * ```tsx\n * const { getFromCache, setInCache, invalidate } = useQueryCache();\n * ```\n */\nexport function useQueryCache(): QueryCacheContextValue {\n  const context = useContext(QueryCacheContext);\n\n  // Create a stable fallback ref for client-side usage without provider\n  const fallbackRef = useRef<Map<string, CacheEntry> | null>(null);\n\n  const fallbackValue = useMemo<QueryCacheContextValue | null>(() => {\n    // Only create fallback on client side\n    if (typeof window === \"undefined\") {\n      return null;\n    }\n\n    if (!fallbackRef.current) {\n      fallbackRef.current = getClientFallbackCache();\n    }\n\n    return createCacheOperations(\n      fallbackRef as React.MutableRefObject<Map<string, CacheEntry>>\n    );\n  }, []);\n\n  if (context) {\n    return context;\n  }\n\n  // In SSR without provider, throw error to prevent data leaking\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"QueryCacheProvider is required for SSR. \" +\n        \"Wrap your application with <QueryCacheProvider> to enable request-scoped caching.\"\n    );\n  }\n\n  // On client without provider, use fallback (for tests or simple client-only apps)\n  if (fallbackValue) {\n    return fallbackValue;\n  }\n\n  // This should never happen, but TypeScript needs it\n  throw new Error(\"Failed to initialize query cache\");\n}\n\n/**\n * Hook to invalidate queries\n *\n * Provides convenient methods to invalidate cached queries.\n *\n * @example\n * ```tsx\n * const { invalidate, invalidateByPrefix, invalidateAll } = useInvalidateQueries();\n *\n * // Invalidate a specific query\n * invalidate(['products', 'list']);\n *\n * // Invalidate all queries starting with 'products'\n * invalidateByPrefix('products');\n *\n * // Clear all cache\n * invalidateAll();\n * ```\n */\nexport function useInvalidateQueries() {\n  const cache = useQueryCache();\n\n  const invalidate = useCallback(\n    (queryKey: unknown[]): void => {\n      const cacheKey = JSON.stringify(queryKey);\n      cache.invalidate(cacheKey);\n    },\n    [cache]\n  );\n\n  const invalidateByPrefix = useCallback(\n    (prefix: string | unknown[]): void => {\n      const prefixStr =\n        typeof prefix === \"string\" ? prefix : JSON.stringify(prefix);\n      // Remove the trailing bracket to match partial keys\n      const normalizedPrefix = prefixStr.endsWith(\"]\")\n        ? prefixStr.slice(0, -1)\n        : prefixStr;\n      cache.invalidateByPrefix(normalizedPrefix);\n    },\n    [cache]\n  );\n\n  const invalidateAll = useCallback((): void => {\n    cache.invalidateAll();\n  }, [cache]);\n\n  return {\n    invalidate,\n    invalidateByPrefix,\n    invalidateAll,\n  };\n}\n\n/**\n * Type for useInvalidateQueries return value\n */\nexport type UseInvalidateQueriesResult = ReturnType<typeof useInvalidateQueries>;\n","/**\n * Generic API Query Hook\n *\n * Provides a reusable hook for fetching data with caching, loading states,\n * and error handling. Works with any async function.\n *\n * Uses React Context for SSR-safe request-scoped caching.\n */\n\nimport { useState, useEffect, useCallback, useRef } from \"react\";\nimport { useQueryCache, useInvalidateQueries } from \"./QueryCacheContext\";\n\n/**\n * Options that can be passed to the query function\n */\nexport interface QueryFnContext {\n  /** AbortSignal for cancelling the request */\n  signal: AbortSignal;\n}\n\n/**\n * Query state\n */\nexport interface QueryState<T> {\n  /** The fetched data */\n  data: T | null;\n  /** Loading state */\n  isLoading: boolean;\n  /** Error if any */\n  error: Error | null;\n  /** Whether data has been fetched at least once */\n  isSuccess: boolean;\n  /** Whether the query is currently fetching (includes refetches) */\n  isFetching: boolean;\n}\n\n/**\n * Query options\n */\nexport interface UseApiQueryOptions<T> {\n  /** Whether to enable the query */\n  enabled?: boolean;\n  /** Initial data */\n  initialData?: T;\n  /** Stale time in ms (default: 0 - always stale) */\n  staleTime?: number;\n  /** Cache time in ms (default: 5 minutes) */\n  cacheTime?: number;\n  /** Retry count (default: 3) */\n  retryCount?: number;\n  /** Retry delay in ms (default: 1000) */\n  retryDelay?: number;\n  /** On success callback */\n  onSuccess?: (data: T) => void;\n  /** On error callback */\n  onError?: (error: Error) => void;\n  /** Refetch on window focus (default: false) */\n  refetchOnWindowFocus?: boolean;\n}\n\n/**\n * Query result\n */\nexport interface UseApiQueryResult<T> extends QueryState<T> {\n  /** Manually refetch the data */\n  refetch: () => Promise<void>;\n  /** Reset the query state */\n  reset: () => void;\n}\n\n/**\n * Generic API query hook\n *\n * @param queryKey - Unique key for the query (used for caching)\n * @param queryFn - Async function to fetch data (optionally receives context with abort signal)\n * @param options - Query options\n * @returns Query result with data, loading state, and refetch function\n *\n * @example\n * ```typescript\n * const { data, isLoading, error, refetch } = useApiQuery(\n *   [\"products\", categoryId],\n *   ({ signal }) => api.products.list({ categoryId }, { signal }),\n *   { staleTime: 60000 }\n * );\n * ```\n */\nexport function useApiQuery<T>(\n  queryKey: unknown[],\n  queryFn: (context?: QueryFnContext) => Promise<T>,\n  options: UseApiQueryOptions<T> = {}\n): UseApiQueryResult<T> {\n  const {\n    enabled = true,\n    initialData,\n    staleTime = 0,\n    cacheTime = 5 * 60 * 1000,\n    retryCount = 3,\n    retryDelay = 1000,\n    onSuccess,\n    onError,\n    refetchOnWindowFocus = false,\n  } = options;\n\n  const cache = useQueryCache();\n  const cacheKey = JSON.stringify(queryKey);\n  const retryCountRef = useRef(0);\n  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const isMountedRef = useRef(true);\n\n  const [state, setState] = useState<QueryState<T>>(() => {\n    // Check cache first\n    if (cache.hasValidCache(cacheKey, cacheTime)) {\n      const cachedData = cache.getCachedData<T>(cacheKey);\n      if (cachedData !== null) {\n        return {\n          data: cachedData,\n          isLoading: false,\n          error: null,\n          isSuccess: true,\n          isFetching: false,\n        };\n      }\n    }\n\n    return {\n      data: initialData ?? null,\n      isLoading: enabled,\n      error: null,\n      isSuccess: false,\n      isFetching: enabled,\n    };\n  });\n\n  const fetchData = useCallback(\n    async (isRefetch = false) => {\n      if (!isRefetch) {\n        // Check if cached data is still fresh\n        const cachedData = cache.getFromCache<T>(cacheKey, staleTime);\n        if (cachedData !== null) {\n          setState((prev) => ({\n            ...prev,\n            data: cachedData,\n            isLoading: false,\n            isSuccess: true,\n            isFetching: false,\n          }));\n          return;\n        }\n      }\n\n      // Cancel any pending retry timeout\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n        retryTimeoutRef.current = null;\n      }\n\n      // Abort any in-flight request\n      abortControllerRef.current?.abort();\n      abortControllerRef.current = new AbortController();\n      const signal = abortControllerRef.current.signal;\n\n      setState((prev) => ({\n        ...prev,\n        isLoading: !prev.data,\n        isFetching: true,\n        error: null,\n      }));\n\n      try {\n        const data = await queryFn({ signal });\n\n        // Check if component is still mounted and request wasn't aborted\n        if (!isMountedRef.current || signal.aborted) return;\n\n        // Update cache\n        cache.setInCache(cacheKey, data);\n\n        setState({\n          data,\n          isLoading: false,\n          error: null,\n          isSuccess: true,\n          isFetching: false,\n        });\n\n        retryCountRef.current = 0;\n        onSuccess?.(data);\n      } catch (err) {\n        // Ignore abort errors\n        if (err instanceof Error && err.name === \"AbortError\") {\n          return;\n        }\n\n        // Check if component is still mounted\n        if (!isMountedRef.current) return;\n\n        const error = err instanceof Error ? err : new Error(String(err));\n\n        // Retry logic\n        if (retryCountRef.current < retryCount) {\n          retryCountRef.current++;\n          retryTimeoutRef.current = setTimeout(\n            () => fetchData(isRefetch),\n            retryDelay * retryCountRef.current\n          );\n          return;\n        }\n\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error,\n          isFetching: false,\n        }));\n\n        retryCountRef.current = 0;\n        onError?.(error);\n      }\n    },\n    [cacheKey, queryFn, staleTime, retryCount, retryDelay, onSuccess, onError, cache]\n  );\n\n  const refetch = useCallback(async () => {\n    retryCountRef.current = 0;\n    await fetchData(true);\n  }, [fetchData]);\n\n  const reset = useCallback(() => {\n    cache.invalidate(cacheKey);\n    setState({\n      data: initialData ?? null,\n      isLoading: false,\n      error: null,\n      isSuccess: false,\n      isFetching: false,\n    });\n  }, [cacheKey, initialData, cache]);\n\n  // Track mounted state and cleanup on unmount\n  useEffect(() => {\n    isMountedRef.current = true;\n\n    return () => {\n      isMountedRef.current = false;\n\n      // Cleanup: cancel any pending retry timeout\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n        retryTimeoutRef.current = null;\n      }\n\n      // Cleanup: abort any in-flight request\n      abortControllerRef.current?.abort();\n    };\n  }, []);\n\n  // Initial fetch\n  useEffect(() => {\n    if (enabled) {\n      fetchData();\n    }\n  }, [enabled, cacheKey]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  // Refetch on window focus (with SSR check)\n  useEffect(() => {\n    // SSR safety: check if window is available\n    if (!refetchOnWindowFocus || !enabled || typeof window === \"undefined\") {\n      return;\n    }\n\n    const handleFocus = () => {\n      const cachedData = cache.getFromCache<T>(cacheKey, staleTime);\n      if (cachedData === null) {\n        fetchData(true);\n      }\n    };\n\n    window.addEventListener(\"focus\", handleFocus);\n    return () => window.removeEventListener(\"focus\", handleFocus);\n  }, [refetchOnWindowFocus, enabled, cacheKey, staleTime, fetchData, cache]);\n\n  return {\n    ...state,\n    refetch,\n    reset,\n  };\n}\n\n/**\n * Clear the query cache\n *\n * @deprecated Use useInvalidateQueries().invalidateAll() instead for SSR-safe cache clearing.\n * This function is kept for backward compatibility but only works with the context provider.\n */\nexport function clearQueryCache(): void {\n  // This is a no-op now - use useInvalidateQueries hook instead\n  console.warn(\n    \"clearQueryCache() is deprecated. Use useInvalidateQueries().invalidateAll() instead.\"\n  );\n}\n\n/**\n * Invalidate specific query keys\n *\n * @deprecated Use useInvalidateQueries().invalidate(queryKey) instead for SSR-safe cache invalidation.\n * This function is kept for backward compatibility but only works with the context provider.\n */\nexport function invalidateQueries(_queryKey: unknown[]): void {\n  // This is a no-op now - use useInvalidateQueries hook instead\n  console.warn(\n    \"invalidateQueries() is deprecated. Use useInvalidateQueries().invalidate(queryKey) instead.\"\n  );\n}\n\n// Re-export cache context utilities\nexport { useInvalidateQueries } from \"./QueryCacheContext\";\n","/**\n * Generic API Mutation Hook\n *\n * Provides a reusable hook for performing mutations (create, update, delete)\n * with loading states, error handling, and optimistic updates.\n */\n\nimport { useState, useCallback } from \"react\";\nimport { invalidateQueries } from \"./useApiQuery\";\n\n/**\n * Mutation state\n */\nexport interface MutationState<TData> {\n  /** The result data */\n  data: TData | null;\n  /** Loading state */\n  isLoading: boolean;\n  /** Error if any */\n  error: Error | null;\n  /** Whether mutation was successful */\n  isSuccess: boolean;\n  /** Whether mutation resulted in error */\n  isError: boolean;\n}\n\n/**\n * Mutation options\n */\nexport interface UseApiMutationOptions<TData, TVariables> {\n  /** On success callback */\n  onSuccess?: (data: TData, variables: TVariables) => void;\n  /** On error callback */\n  onError?: (error: Error, variables: TVariables) => void;\n  /** On settled callback (runs after success or error) */\n  onSettled?: (data: TData | null, error: Error | null, variables: TVariables) => void;\n  /** Query keys to invalidate on success */\n  invalidateKeys?: unknown[][];\n  /** Retry count (default: 0) */\n  retryCount?: number;\n}\n\n/**\n * Mutation result\n */\nexport interface UseApiMutationResult<TData, TVariables> extends MutationState<TData> {\n  /** Execute the mutation */\n  mutate: (variables: TVariables) => void;\n  /** Execute the mutation and return a promise */\n  mutateAsync: (variables: TVariables) => Promise<TData>;\n  /** Reset the mutation state */\n  reset: () => void;\n}\n\n/**\n * Generic API mutation hook\n *\n * @param mutationFn - Async function to perform the mutation\n * @param options - Mutation options\n * @returns Mutation result with mutate function and state\n *\n * @example\n * ```typescript\n * const { mutate, isLoading, error } = useApiMutation(\n *   (input) => api.cart.addItem(cartId, input),\n *   {\n *     onSuccess: () => toast.success('Item added!'),\n *     invalidateKeys: [['cart', cartId]]\n *   }\n * );\n *\n * // Usage\n * mutate({ productId: 'prod_123', quantity: 2 });\n * ```\n */\nexport function useApiMutation<TData, TVariables = void>(\n  mutationFn: (variables: TVariables) => Promise<TData>,\n  options: UseApiMutationOptions<TData, TVariables> = {}\n): UseApiMutationResult<TData, TVariables> {\n  const {\n    onSuccess,\n    onError,\n    onSettled,\n    invalidateKeys = [],\n    retryCount = 0,\n  } = options;\n\n  const [state, setState] = useState<MutationState<TData>>({\n    data: null,\n    isLoading: false,\n    error: null,\n    isSuccess: false,\n    isError: false,\n  });\n\n  const reset = useCallback(() => {\n    setState({\n      data: null,\n      isLoading: false,\n      error: null,\n      isSuccess: false,\n      isError: false,\n    });\n  }, []);\n\n  const mutateAsync = useCallback(\n    async (variables: TVariables): Promise<TData> => {\n      setState({\n        data: null,\n        isLoading: true,\n        error: null,\n        isSuccess: false,\n        isError: false,\n      });\n\n      let lastError: Error | null = null;\n      let attempts = 0;\n\n      while (attempts <= retryCount) {\n        try {\n          const data = await mutationFn(variables);\n\n          setState({\n            data,\n            isLoading: false,\n            error: null,\n            isSuccess: true,\n            isError: false,\n          });\n\n          // Invalidate related queries\n          for (const key of invalidateKeys) {\n            invalidateQueries(key);\n          }\n\n          onSuccess?.(data, variables);\n          onSettled?.(data, null, variables);\n\n          return data;\n        } catch (err) {\n          lastError = err instanceof Error ? err : new Error(String(err));\n          attempts++;\n\n          if (attempts > retryCount) {\n            break;\n          }\n\n          // Wait before retry (exponential backoff)\n          await new Promise((resolve) => setTimeout(resolve, 1000 * attempts));\n        }\n      }\n\n      // All retries failed\n      setState({\n        data: null,\n        isLoading: false,\n        error: lastError,\n        isSuccess: false,\n        isError: true,\n      });\n\n      onError?.(lastError!, variables);\n      onSettled?.(null, lastError, variables);\n\n      throw lastError;\n    },\n    [mutationFn, retryCount, invalidateKeys, onSuccess, onError, onSettled]\n  );\n\n  const mutate = useCallback(\n    (variables: TVariables): void => {\n      mutateAsync(variables).catch(() => {\n        // Error is already handled in state\n      });\n    },\n    [mutateAsync]\n  );\n\n  return {\n    ...state,\n    mutate,\n    mutateAsync,\n    reset,\n  };\n}\n"],"mappings":"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","names":["import_react","import_react"]}