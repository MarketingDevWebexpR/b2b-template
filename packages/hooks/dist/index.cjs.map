{"version":3,"sources":["../src/index.ts","../src/api/useApiQuery.ts","../src/api/useApiMutation.ts","../src/b2b/useCompany.ts","../src/b2b/useQuotes.ts","../src/b2b/useApprovals.ts","../src/b2b/useSpendingLimits.ts","../src/cart/useCart.ts","../src/cart/useBulkCart.ts","../src/utils/useStorage.ts"],"sourcesContent":["/**\n * @maison/hooks\n *\n * Shared React hooks for B2B e-commerce applications.\n * Platform-agnostic hooks that work with web and mobile.\n */\n\n// Re-export API hooks\nexport {\n  useApiQuery,\n  clearQueryCache,\n  invalidateQueries,\n  type QueryState,\n  type UseApiQueryOptions,\n  type UseApiQueryResult,\n  useApiMutation,\n  type MutationState,\n  type UseApiMutationOptions,\n  type UseApiMutationResult,\n} from \"./api\";\n\n// Re-export B2B hooks\nexport {\n  useCompany,\n  type CompanyState,\n  type UseCompanyOptions,\n  type UseCompanyResult,\n  type B2BAction,\n  useQuotes,\n  type QuoteFilters,\n  type CreateQuoteInput,\n  type RespondToQuoteInput,\n  type UseQuotesResult,\n  useApprovals,\n  type Approval,\n  type ApprovalType,\n  type ApprovalFilters,\n  type ApprovalDecisionInput,\n  type UseApprovalsResult,\n  type RequestApprovalInput,\n  useSpendingLimits,\n  type SpendingSummary,\n  type UseSpendingLimitsResult,\n  type SpendingHistoryEntry,\n} from \"./b2b\";\n\n// Re-export cart hooks\nexport {\n  useCart,\n  type CartItemWithId,\n  type ExtendedCart,\n  type CartUpdateInput,\n  type UseCartOptions,\n  type UseCartResult,\n  useBulkCart,\n  type BulkItemInput,\n  type CSVImportResult,\n  type UseBulkCartOptions,\n  type UseBulkCartResult,\n} from \"./cart\";\n\n// Re-export utility hooks\nexport {\n  useStorage,\n  useSessionStorage,\n  setStorageAdapter,\n  type StorageAdapter,\n  type UseStorageOptions,\n  type UseStorageResult,\n} from \"./utils\";\n","/**\n * Generic API Query Hook\n *\n * Provides a reusable hook for fetching data with caching, loading states,\n * and error handling. Works with any async function.\n */\n\nimport { useState, useEffect, useCallback, useRef } from \"react\";\n\n/**\n * Query state\n */\nexport interface QueryState<T> {\n  /** The fetched data */\n  data: T | null;\n  /** Loading state */\n  isLoading: boolean;\n  /** Error if any */\n  error: Error | null;\n  /** Whether data has been fetched at least once */\n  isSuccess: boolean;\n  /** Whether the query is currently fetching (includes refetches) */\n  isFetching: boolean;\n}\n\n/**\n * Query options\n */\nexport interface UseApiQueryOptions<T> {\n  /** Whether to enable the query */\n  enabled?: boolean;\n  /** Initial data */\n  initialData?: T;\n  /** Stale time in ms (default: 0 - always stale) */\n  staleTime?: number;\n  /** Cache time in ms (default: 5 minutes) */\n  cacheTime?: number;\n  /** Retry count (default: 3) */\n  retryCount?: number;\n  /** Retry delay in ms (default: 1000) */\n  retryDelay?: number;\n  /** On success callback */\n  onSuccess?: (data: T) => void;\n  /** On error callback */\n  onError?: (error: Error) => void;\n  /** Refetch on window focus (default: false) */\n  refetchOnWindowFocus?: boolean;\n}\n\n/**\n * Query result\n */\nexport interface UseApiQueryResult<T> extends QueryState<T> {\n  /** Manually refetch the data */\n  refetch: () => Promise<void>;\n  /** Reset the query state */\n  reset: () => void;\n}\n\n// Simple in-memory cache\nconst queryCache = new Map<string, { data: unknown; timestamp: number }>();\n\n/**\n * Generic API query hook\n *\n * @param queryKey - Unique key for the query (used for caching)\n * @param queryFn - Async function to fetch data\n * @param options - Query options\n * @returns Query result with data, loading state, and refetch function\n *\n * @example\n * ```typescript\n * const { data, isLoading, error, refetch } = useApiQuery(\n *   [\"products\", categoryId],\n *   () => api.products.list({ categoryId }),\n *   { staleTime: 60000 }\n * );\n * ```\n */\nexport function useApiQuery<T>(\n  queryKey: unknown[],\n  queryFn: () => Promise<T>,\n  options: UseApiQueryOptions<T> = {}\n): UseApiQueryResult<T> {\n  const {\n    enabled = true,\n    initialData,\n    staleTime = 0,\n    cacheTime = 5 * 60 * 1000,\n    retryCount = 3,\n    retryDelay = 1000,\n    onSuccess,\n    onError,\n    refetchOnWindowFocus = false,\n  } = options;\n\n  const cacheKey = JSON.stringify(queryKey);\n  const retryCountRef = useRef(0);\n\n  const [state, setState] = useState<QueryState<T>>(() => {\n    // Check cache first\n    const cached = queryCache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < cacheTime) {\n      return {\n        data: cached.data as T,\n        isLoading: false,\n        error: null,\n        isSuccess: true,\n        isFetching: false,\n      };\n    }\n\n    return {\n      data: initialData ?? null,\n      isLoading: enabled,\n      error: null,\n      isSuccess: false,\n      isFetching: enabled,\n    };\n  });\n\n  const fetchData = useCallback(\n    async (isRefetch = false) => {\n      if (!isRefetch) {\n        // Check if cached data is still fresh\n        const cached = queryCache.get(cacheKey);\n        if (cached && Date.now() - cached.timestamp < staleTime) {\n          setState((prev) => ({\n            ...prev,\n            data: cached.data as T,\n            isLoading: false,\n            isSuccess: true,\n            isFetching: false,\n          }));\n          return;\n        }\n      }\n\n      setState((prev) => ({\n        ...prev,\n        isLoading: !prev.data,\n        isFetching: true,\n        error: null,\n      }));\n\n      try {\n        const data = await queryFn();\n\n        // Update cache\n        queryCache.set(cacheKey, { data, timestamp: Date.now() });\n\n        setState({\n          data,\n          isLoading: false,\n          error: null,\n          isSuccess: true,\n          isFetching: false,\n        });\n\n        retryCountRef.current = 0;\n        onSuccess?.(data);\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err));\n\n        // Retry logic\n        if (retryCountRef.current < retryCount) {\n          retryCountRef.current++;\n          setTimeout(() => fetchData(isRefetch), retryDelay * retryCountRef.current);\n          return;\n        }\n\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error,\n          isFetching: false,\n        }));\n\n        retryCountRef.current = 0;\n        onError?.(error);\n      }\n    },\n    [cacheKey, queryFn, staleTime, retryCount, retryDelay, onSuccess, onError]\n  );\n\n  const refetch = useCallback(async () => {\n    retryCountRef.current = 0;\n    await fetchData(true);\n  }, [fetchData]);\n\n  const reset = useCallback(() => {\n    queryCache.delete(cacheKey);\n    setState({\n      data: initialData ?? null,\n      isLoading: false,\n      error: null,\n      isSuccess: false,\n      isFetching: false,\n    });\n  }, [cacheKey, initialData]);\n\n  // Initial fetch\n  useEffect(() => {\n    if (enabled) {\n      fetchData();\n    }\n  }, [enabled, cacheKey]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  // Refetch on window focus\n  useEffect(() => {\n    if (!refetchOnWindowFocus || !enabled) return;\n\n    const handleFocus = () => {\n      const cached = queryCache.get(cacheKey);\n      if (!cached || Date.now() - cached.timestamp >= staleTime) {\n        fetchData(true);\n      }\n    };\n\n    window.addEventListener(\"focus\", handleFocus);\n    return () => window.removeEventListener(\"focus\", handleFocus);\n  }, [refetchOnWindowFocus, enabled, cacheKey, staleTime, fetchData]);\n\n  return {\n    ...state,\n    refetch,\n    reset,\n  };\n}\n\n/**\n * Clear the query cache\n */\nexport function clearQueryCache(): void {\n  queryCache.clear();\n}\n\n/**\n * Invalidate specific query keys\n */\nexport function invalidateQueries(queryKey: unknown[]): void {\n  const cacheKey = JSON.stringify(queryKey);\n  queryCache.delete(cacheKey);\n}\n","/**\n * Generic API Mutation Hook\n *\n * Provides a reusable hook for performing mutations (create, update, delete)\n * with loading states, error handling, and optimistic updates.\n */\n\nimport { useState, useCallback } from \"react\";\nimport { invalidateQueries } from \"./useApiQuery\";\n\n/**\n * Mutation state\n */\nexport interface MutationState<TData> {\n  /** The result data */\n  data: TData | null;\n  /** Loading state */\n  isLoading: boolean;\n  /** Error if any */\n  error: Error | null;\n  /** Whether mutation was successful */\n  isSuccess: boolean;\n  /** Whether mutation resulted in error */\n  isError: boolean;\n}\n\n/**\n * Mutation options\n */\nexport interface UseApiMutationOptions<TData, TVariables> {\n  /** On success callback */\n  onSuccess?: (data: TData, variables: TVariables) => void;\n  /** On error callback */\n  onError?: (error: Error, variables: TVariables) => void;\n  /** On settled callback (runs after success or error) */\n  onSettled?: (data: TData | null, error: Error | null, variables: TVariables) => void;\n  /** Query keys to invalidate on success */\n  invalidateKeys?: unknown[][];\n  /** Retry count (default: 0) */\n  retryCount?: number;\n}\n\n/**\n * Mutation result\n */\nexport interface UseApiMutationResult<TData, TVariables> extends MutationState<TData> {\n  /** Execute the mutation */\n  mutate: (variables: TVariables) => void;\n  /** Execute the mutation and return a promise */\n  mutateAsync: (variables: TVariables) => Promise<TData>;\n  /** Reset the mutation state */\n  reset: () => void;\n}\n\n/**\n * Generic API mutation hook\n *\n * @param mutationFn - Async function to perform the mutation\n * @param options - Mutation options\n * @returns Mutation result with mutate function and state\n *\n * @example\n * ```typescript\n * const { mutate, isLoading, error } = useApiMutation(\n *   (input) => api.cart.addItem(cartId, input),\n *   {\n *     onSuccess: () => toast.success('Item added!'),\n *     invalidateKeys: [['cart', cartId]]\n *   }\n * );\n *\n * // Usage\n * mutate({ productId: 'prod_123', quantity: 2 });\n * ```\n */\nexport function useApiMutation<TData, TVariables = void>(\n  mutationFn: (variables: TVariables) => Promise<TData>,\n  options: UseApiMutationOptions<TData, TVariables> = {}\n): UseApiMutationResult<TData, TVariables> {\n  const {\n    onSuccess,\n    onError,\n    onSettled,\n    invalidateKeys = [],\n    retryCount = 0,\n  } = options;\n\n  const [state, setState] = useState<MutationState<TData>>({\n    data: null,\n    isLoading: false,\n    error: null,\n    isSuccess: false,\n    isError: false,\n  });\n\n  const reset = useCallback(() => {\n    setState({\n      data: null,\n      isLoading: false,\n      error: null,\n      isSuccess: false,\n      isError: false,\n    });\n  }, []);\n\n  const mutateAsync = useCallback(\n    async (variables: TVariables): Promise<TData> => {\n      setState({\n        data: null,\n        isLoading: true,\n        error: null,\n        isSuccess: false,\n        isError: false,\n      });\n\n      let lastError: Error | null = null;\n      let attempts = 0;\n\n      while (attempts <= retryCount) {\n        try {\n          const data = await mutationFn(variables);\n\n          setState({\n            data,\n            isLoading: false,\n            error: null,\n            isSuccess: true,\n            isError: false,\n          });\n\n          // Invalidate related queries\n          for (const key of invalidateKeys) {\n            invalidateQueries(key);\n          }\n\n          onSuccess?.(data, variables);\n          onSettled?.(data, null, variables);\n\n          return data;\n        } catch (err) {\n          lastError = err instanceof Error ? err : new Error(String(err));\n          attempts++;\n\n          if (attempts > retryCount) {\n            break;\n          }\n\n          // Wait before retry (exponential backoff)\n          await new Promise((resolve) => setTimeout(resolve, 1000 * attempts));\n        }\n      }\n\n      // All retries failed\n      setState({\n        data: null,\n        isLoading: false,\n        error: lastError,\n        isSuccess: false,\n        isError: true,\n      });\n\n      onError?.(lastError!, variables);\n      onSettled?.(null, lastError, variables);\n\n      throw lastError;\n    },\n    [mutationFn, retryCount, invalidateKeys, onSuccess, onError, onSettled]\n  );\n\n  const mutate = useCallback(\n    (variables: TVariables): void => {\n      mutateAsync(variables).catch(() => {\n        // Error is already handled in state\n      });\n    },\n    [mutateAsync]\n  );\n\n  return {\n    ...state,\n    mutate,\n    mutateAsync,\n    reset,\n  };\n}\n","/**\n * Company Hook\n *\n * Provides access to the current B2B company context and company data.\n */\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport type { Company, Employee } from \"@maison/types\";\n\n/**\n * Company state\n */\nexport interface CompanyState {\n  /** Current company */\n  company: Company | null;\n  /** Current employee */\n  employee: Employee | null;\n  /** Loading state */\n  isLoading: boolean;\n  /** Error if any */\n  error: Error | null;\n  /** Whether B2B context is active */\n  isB2BActive: boolean;\n}\n\n/**\n * Company hook options\n */\nexport interface UseCompanyOptions {\n  /** Company ID to fetch (optional, uses context if not provided) */\n  companyId?: string;\n  /** Whether to fetch employees */\n  includeEmployees?: boolean;\n  /** Auto-refresh interval in ms */\n  refreshInterval?: number;\n}\n\n/**\n * Company hook result\n */\nexport interface UseCompanyResult extends CompanyState {\n  /** Set the active company */\n  setCompany: (companyId: string) => Promise<void>;\n  /** Clear the company context */\n  clearCompany: () => void;\n  /** Refresh company data */\n  refresh: () => Promise<void>;\n  /** List employees (if B2B enabled) */\n  employees: Employee[];\n  /** Check if current user can perform an action */\n  canPerform: (action: B2BAction) => boolean;\n}\n\n/**\n * B2B actions that can be checked for permissions\n */\nexport type B2BAction =\n  | \"create_quote\"\n  | \"approve_order\"\n  | \"manage_employees\"\n  | \"view_spending\"\n  | \"edit_company\"\n  | \"place_order\";\n\n/**\n * Hook for managing B2B company context\n *\n * @param api - API client instance\n * @param options - Hook options\n * @returns Company state and actions\n *\n * @example\n * ```typescript\n * const { company, employee, isB2BActive, setCompany, canPerform } = useCompany(api);\n *\n * if (isB2BActive && canPerform('create_quote')) {\n *   // Show quote creation UI\n * }\n * ```\n */\nexport function useCompany(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  api: any, // ICommerceClient - using any to avoid circular dep\n  options: UseCompanyOptions = {}\n): UseCompanyResult {\n  const { companyId, includeEmployees = false, refreshInterval } = options;\n\n  const [state, setState] = useState<CompanyState>({\n    company: null,\n    employee: null,\n    isLoading: false,\n    error: null,\n    isB2BActive: false,\n  });\n\n  const [employees, setEmployees] = useState<Employee[]>([]);\n\n  const fetchCompany = useCallback(\n    async (id?: string) => {\n      const targetId = id ?? companyId;\n      if (!targetId || !api?.b2b?.companies) {\n        return;\n      }\n\n      setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n      try {\n        const company = await api.b2b.companies.get(targetId);\n        const b2bContext = api.getB2BContext?.();\n\n        let employee: Employee | null = null;\n        if (b2bContext?.employeeId) {\n          try {\n            employee = await api.b2b.employees.get(b2bContext.employeeId);\n          } catch {\n            // Employee not found, continue without\n          }\n        }\n\n        if (includeEmployees) {\n          const employeeList = await api.b2b.employees.list(targetId);\n          setEmployees(employeeList);\n        }\n\n        setState({\n          company,\n          employee,\n          isLoading: false,\n          error: null,\n          isB2BActive: true,\n        });\n      } catch (err) {\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error: err instanceof Error ? err : new Error(String(err)),\n        }));\n      }\n    },\n    [api, companyId, includeEmployees]\n  );\n\n  const setCompany = useCallback(\n    async (newCompanyId: string) => {\n      api?.setB2BContext?.(newCompanyId);\n      await fetchCompany(newCompanyId);\n    },\n    [api, fetchCompany]\n  );\n\n  const clearCompany = useCallback(() => {\n    api?.clearB2BContext?.();\n    setState({\n      company: null,\n      employee: null,\n      isLoading: false,\n      error: null,\n      isB2BActive: false,\n    });\n    setEmployees([]);\n  }, [api]);\n\n  const refresh = useCallback(async () => {\n    const context = api?.getB2BContext?.();\n    if (context?.companyId) {\n      await fetchCompany(context.companyId);\n    }\n  }, [api, fetchCompany]);\n\n  const canPerform = useCallback(\n    (action: B2BAction): boolean => {\n      if (!state.isB2BActive || !state.employee) {\n        return false;\n      }\n\n      const permissions = state.employee.permissions ?? [];\n      const role = state.employee.role;\n\n      // Owner and admin can do everything\n      if (role === \"owner\" || role === \"admin\") {\n        return true;\n      }\n\n      // Check specific permissions based on the actual EmployeePermission types\n      switch (action) {\n        case \"create_quote\":\n          return permissions.includes(\"quotes.create\") || role === \"purchaser\";\n        case \"approve_order\":\n          return permissions.includes(\"orders.approve\") || role === \"manager\";\n        case \"manage_employees\":\n          return permissions.includes(\"company.manage_employees\");\n        case \"view_spending\":\n          return permissions.includes(\"spending.view_reports\") || role !== \"viewer\";\n        case \"edit_company\":\n          return permissions.includes(\"company.edit\");\n        case \"place_order\":\n          return permissions.includes(\"orders.create\") || role === \"purchaser\" || role === \"manager\";\n        default:\n          return false;\n      }\n    },\n    [state.isB2BActive, state.employee]\n  );\n\n  // Initial fetch\n  useEffect(() => {\n    const context = api?.getB2BContext?.();\n    if (context?.companyId || companyId) {\n      fetchCompany(context?.companyId ?? companyId);\n    }\n  }, [api, companyId]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  // Auto-refresh\n  useEffect(() => {\n    if (!refreshInterval || !state.isB2BActive) return;\n\n    const interval = setInterval(refresh, refreshInterval);\n    return () => clearInterval(interval);\n  }, [refreshInterval, state.isB2BActive, refresh]);\n\n  return {\n    ...state,\n    employees,\n    setCompany,\n    clearCompany,\n    refresh,\n    canPerform,\n  };\n}\n","/**\n * Quotes Hook\n *\n * Provides access to B2B quote management functionality.\n */\n\nimport { useState, useCallback } from \"react\";\nimport type { Quote, QuoteStatus } from \"@maison/types\";\nimport { useApiQuery, invalidateQueries } from \"../api/useApiQuery\";\nimport { useApiMutation } from \"../api/useApiMutation\";\n\n/**\n * Quote filter options\n */\nexport interface QuoteFilters {\n  /** Filter by status */\n  status?: QuoteStatus | QuoteStatus[];\n  /** Filter by company ID */\n  companyId?: string;\n  /** Filter quotes after this date */\n  createdAfter?: string;\n  /** Filter quotes before this date */\n  createdBefore?: string;\n  /** Search by quote number or product */\n  search?: string;\n}\n\n/**\n * Quote creation input\n */\nexport interface CreateQuoteInput {\n  /** Cart ID to create quote from */\n  cartId: string;\n  /** Quote notes */\n  notes?: string;\n  /** Requested delivery date */\n  requestedDeliveryDate?: string;\n  /** PO number */\n  purchaseOrderNumber?: string;\n}\n\n/**\n * Quote response input\n */\nexport interface RespondToQuoteInput {\n  /** Response message */\n  message?: string;\n  /** Adjusted prices per item */\n  priceAdjustments?: Array<{\n    itemId: string;\n    newPrice: number;\n  }>;\n  /** Validity period in days */\n  validityDays?: number;\n}\n\n/**\n * Quotes hook result\n */\nexport interface UseQuotesResult {\n  /** List of quotes */\n  quotes: Quote[];\n  /** Loading state */\n  isLoading: boolean;\n  /** Error if any */\n  error: Error | null;\n  /** Fetch quotes */\n  fetchQuotes: (filters?: QuoteFilters) => void;\n  /** Get a single quote */\n  getQuote: (quoteId: string) => Promise<Quote>;\n  /** Create quote from cart */\n  createFromCart: (input: CreateQuoteInput) => Promise<Quote>;\n  /** Submit quote for review */\n  submitQuote: (quoteId: string) => Promise<Quote>;\n  /** Accept a quote */\n  acceptQuote: (quoteId: string) => Promise<Quote>;\n  /** Reject a quote */\n  rejectQuote: (quoteId: string, reason?: string) => Promise<Quote>;\n  /** Respond to quote (for admin/sales) */\n  respondToQuote: (quoteId: string, input: RespondToQuoteInput) => Promise<Quote>;\n  /** Convert quote to order */\n  convertToOrder: (quoteId: string) => Promise<{ orderId: string }>;\n  /** Delete draft quote */\n  deleteQuote: (quoteId: string) => Promise<void>;\n  /** Current filters */\n  filters: QuoteFilters;\n  /** Set filters */\n  setFilters: (filters: QuoteFilters) => void;\n  /** Refresh quotes */\n  refresh: () => void;\n}\n\n/**\n * Hook for managing B2B quotes\n *\n * @param api - API client instance\n * @param initialFilters - Initial filter values\n * @returns Quotes state and actions\n *\n * @example\n * ```typescript\n * const {\n *   quotes,\n *   isLoading,\n *   createFromCart,\n *   acceptQuote,\n *   setFilters\n * } = useQuotes(api, { status: 'pending' });\n *\n * // Create quote from cart\n * await createFromCart({ cartId: 'cart_123', notes: 'Urgent order' });\n *\n * // Filter by status\n * setFilters({ status: 'responded' });\n * ```\n */\nexport function useQuotes(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  api: any, // ICommerceClient\n  initialFilters: QuoteFilters = {}\n): UseQuotesResult {\n  const [filters, setFilters] = useState<QuoteFilters>(initialFilters);\n\n  // Query for quotes list\n  const {\n    data: quotes,\n    isLoading,\n    error,\n    refetch,\n  } = useApiQuery<Quote[]>(\n    [\"quotes\", filters],\n    async () => {\n      if (!api?.b2b?.quotes) {\n        return [];\n      }\n      const result = await api.b2b.quotes.list(filters);\n      return result.items ?? result;\n    },\n    {\n      enabled: !!api?.b2b?.quotes,\n      staleTime: 30000, // 30 seconds\n    }\n  );\n\n  // Create quote mutation\n  const createMutation = useApiMutation<Quote, CreateQuoteInput>(\n    async (input) => {\n      if (!api?.b2b?.quotes) {\n        throw new Error(\"B2B quotes not available\");\n      }\n      return api.b2b.quotes.createFromCart(input.cartId, input);\n    },\n    {\n      invalidateKeys: [[\"quotes\"]],\n    }\n  );\n\n  // Submit quote mutation\n  const submitMutation = useApiMutation<Quote, string>(\n    async (quoteId) => {\n      if (!api?.b2b?.quotes) {\n        throw new Error(\"B2B quotes not available\");\n      }\n      return api.b2b.quotes.submit(quoteId);\n    },\n    {\n      invalidateKeys: [[\"quotes\"]],\n    }\n  );\n\n  // Accept quote mutation\n  const acceptMutation = useApiMutation<Quote, string>(\n    async (quoteId) => {\n      if (!api?.b2b?.quotes) {\n        throw new Error(\"B2B quotes not available\");\n      }\n      return api.b2b.quotes.accept(quoteId);\n    },\n    {\n      invalidateKeys: [[\"quotes\"]],\n    }\n  );\n\n  // Reject quote mutation\n  const rejectMutation = useApiMutation<Quote, { quoteId: string; reason?: string }>(\n    async ({ quoteId, reason }) => {\n      if (!api?.b2b?.quotes) {\n        throw new Error(\"B2B quotes not available\");\n      }\n      return api.b2b.quotes.reject(quoteId, reason);\n    },\n    {\n      invalidateKeys: [[\"quotes\"]],\n    }\n  );\n\n  // Respond to quote mutation\n  const respondMutation = useApiMutation<Quote, { quoteId: string; input: RespondToQuoteInput }>(\n    async ({ quoteId, input }) => {\n      if (!api?.b2b?.quotes) {\n        throw new Error(\"B2B quotes not available\");\n      }\n      return api.b2b.quotes.respond(quoteId, input);\n    },\n    {\n      invalidateKeys: [[\"quotes\"]],\n    }\n  );\n\n  // Convert to order mutation\n  const convertMutation = useApiMutation<{ orderId: string }, string>(\n    async (quoteId) => {\n      if (!api?.b2b?.quotes) {\n        throw new Error(\"B2B quotes not available\");\n      }\n      return api.b2b.quotes.convertToOrder(quoteId);\n    },\n    {\n      invalidateKeys: [[\"quotes\"], [\"orders\"]],\n    }\n  );\n\n  // Delete quote mutation\n  const deleteMutation = useApiMutation<void, string>(\n    async (quoteId) => {\n      if (!api?.b2b?.quotes) {\n        throw new Error(\"B2B quotes not available\");\n      }\n      return api.b2b.quotes.delete(quoteId);\n    },\n    {\n      invalidateKeys: [[\"quotes\"]],\n    }\n  );\n\n  const getQuote = useCallback(\n    async (quoteId: string): Promise<Quote> => {\n      if (!api?.b2b?.quotes) {\n        throw new Error(\"B2B quotes not available\");\n      }\n      return api.b2b.quotes.get(quoteId);\n    },\n    [api]\n  );\n\n  const fetchQuotes = useCallback(\n    (newFilters?: QuoteFilters) => {\n      if (newFilters) {\n        setFilters(newFilters);\n      }\n      invalidateQueries([\"quotes\", newFilters ?? filters]);\n      refetch();\n    },\n    [filters, refetch]\n  );\n\n  return {\n    quotes: quotes ?? [],\n    isLoading,\n    error,\n    filters,\n    setFilters,\n    fetchQuotes,\n    getQuote,\n    createFromCart: createMutation.mutateAsync,\n    submitQuote: submitMutation.mutateAsync,\n    acceptQuote: acceptMutation.mutateAsync,\n    rejectQuote: (quoteId, reason) =>\n      rejectMutation.mutateAsync({ quoteId, reason }),\n    respondToQuote: (quoteId, input) =>\n      respondMutation.mutateAsync({ quoteId, input }),\n    convertToOrder: convertMutation.mutateAsync,\n    deleteQuote: deleteMutation.mutateAsync,\n    refresh: refetch,\n  };\n}\n","/**\n * Approvals Hook\n *\n * Provides access to B2B approval workflow management.\n */\n\nimport { useState, useCallback } from \"react\";\nimport type { ApprovalRequest, ApprovalStatus, ApprovalEntityType } from \"@maison/types\";\nimport { useApiQuery, invalidateQueries } from \"../api/useApiQuery\";\nimport { useApiMutation } from \"../api/useApiMutation\";\n\n/**\n * Alias for ApprovalRequest for easier usage\n */\nexport type Approval = ApprovalRequest;\n\n/**\n * Alias for ApprovalEntityType for easier usage\n */\nexport type ApprovalType = ApprovalEntityType;\n\n/**\n * Approval filter options\n */\nexport interface ApprovalFilters {\n  /** Filter by status */\n  status?: ApprovalStatus | ApprovalStatus[];\n  /** Filter by type */\n  type?: ApprovalType;\n  /** Filter by company ID */\n  companyId?: string;\n  /** Filter by requester ID */\n  requesterId?: string;\n  /** Only show my pending approvals */\n  pendingForMe?: boolean;\n}\n\n/**\n * Approval decision input\n */\nexport interface ApprovalDecisionInput {\n  /** Whether to approve */\n  approved: boolean;\n  /** Decision comment */\n  comment?: string;\n  /** Forward to another approver */\n  forwardTo?: string;\n}\n\n/**\n * Approvals hook result\n */\nexport interface UseApprovalsResult {\n  /** List of approvals */\n  approvals: Approval[];\n  /** Pending approvals count */\n  pendingCount: number;\n  /** Loading state */\n  isLoading: boolean;\n  /** Error if any */\n  error: Error | null;\n  /** Get approval details */\n  getApproval: (approvalId: string) => Promise<Approval>;\n  /** Approve a request */\n  approve: (approvalId: string, comment?: string) => Promise<Approval>;\n  /** Reject a request */\n  reject: (approvalId: string, comment?: string) => Promise<Approval>;\n  /** Forward approval to another person */\n  forward: (approvalId: string, toEmployeeId: string, comment?: string) => Promise<Approval>;\n  /** Request approval (for order/quote) */\n  requestApproval: (input: RequestApprovalInput) => Promise<Approval>;\n  /** Current filters */\n  filters: ApprovalFilters;\n  /** Set filters */\n  setFilters: (filters: ApprovalFilters) => void;\n  /** Refresh approvals */\n  refresh: () => void;\n}\n\n/**\n * Request approval input\n */\nexport interface RequestApprovalInput {\n  /** Type of approval */\n  type: ApprovalType;\n  /** Related entity ID (order, quote, etc.) */\n  entityId: string;\n  /** Approval amount */\n  amount?: number;\n  /** Request message */\n  message?: string;\n  /** Urgency level */\n  urgency?: \"low\" | \"normal\" | \"high\";\n}\n\n/**\n * Hook for managing B2B approval workflows\n *\n * @param api - API client instance\n * @param initialFilters - Initial filter values\n * @returns Approvals state and actions\n *\n * @example\n * ```typescript\n * const {\n *   approvals,\n *   pendingCount,\n *   approve,\n *   reject,\n *   setFilters\n * } = useApprovals(api, { pendingForMe: true });\n *\n * // Approve a request\n * await approve('approval_123', 'Looks good');\n *\n * // Reject a request\n * await reject('approval_456', 'Budget exceeded');\n * ```\n */\nexport function useApprovals(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  api: any, // ICommerceClient\n  initialFilters: ApprovalFilters = {}\n): UseApprovalsResult {\n  const [filters, setFilters] = useState<ApprovalFilters>(initialFilters);\n\n  // Query for approvals list\n  const {\n    data: approvals,\n    isLoading,\n    error,\n    refetch,\n  } = useApiQuery<Approval[]>(\n    [\"approvals\", filters],\n    async () => {\n      if (!api?.b2b?.approvals) {\n        return [];\n      }\n      const result = await api.b2b.approvals.list(filters);\n      return result.items ?? result;\n    },\n    {\n      enabled: !!api?.b2b?.approvals,\n      staleTime: 15000, // 15 seconds - approvals need fresher data\n    }\n  );\n\n  // Count pending approvals\n  const pendingCount = (approvals ?? []).filter(\n    (a) => a.status === \"pending\"\n  ).length;\n\n  // Approve mutation\n  const approveMutation = useApiMutation<Approval, { approvalId: string; comment?: string }>(\n    async ({ approvalId, comment }) => {\n      if (!api?.b2b?.approvals) {\n        throw new Error(\"B2B approvals not available\");\n      }\n      return api.b2b.approvals.decide(approvalId, {\n        approved: true,\n        comment,\n      });\n    },\n    {\n      invalidateKeys: [[\"approvals\"], [\"orders\"], [\"quotes\"]],\n    }\n  );\n\n  // Reject mutation\n  const rejectMutation = useApiMutation<Approval, { approvalId: string; comment?: string }>(\n    async ({ approvalId, comment }) => {\n      if (!api?.b2b?.approvals) {\n        throw new Error(\"B2B approvals not available\");\n      }\n      return api.b2b.approvals.decide(approvalId, {\n        approved: false,\n        comment,\n      });\n    },\n    {\n      invalidateKeys: [[\"approvals\"], [\"orders\"], [\"quotes\"]],\n    }\n  );\n\n  // Forward mutation\n  const forwardMutation = useApiMutation<\n    Approval,\n    { approvalId: string; toEmployeeId: string; comment?: string }\n  >(\n    async ({ approvalId, toEmployeeId, comment }) => {\n      if (!api?.b2b?.approvals) {\n        throw new Error(\"B2B approvals not available\");\n      }\n      return api.b2b.approvals.forward(approvalId, toEmployeeId, comment);\n    },\n    {\n      invalidateKeys: [[\"approvals\"]],\n    }\n  );\n\n  // Request approval mutation\n  const requestMutation = useApiMutation<Approval, RequestApprovalInput>(\n    async (input) => {\n      if (!api?.b2b?.approvals) {\n        throw new Error(\"B2B approvals not available\");\n      }\n      return api.b2b.approvals.request(input);\n    },\n    {\n      invalidateKeys: [[\"approvals\"]],\n    }\n  );\n\n  const getApproval = useCallback(\n    async (approvalId: string): Promise<Approval> => {\n      if (!api?.b2b?.approvals) {\n        throw new Error(\"B2B approvals not available\");\n      }\n      return api.b2b.approvals.get(approvalId);\n    },\n    [api]\n  );\n\n  return {\n    approvals: approvals ?? [],\n    pendingCount,\n    isLoading,\n    error,\n    filters,\n    setFilters: (newFilters) => {\n      setFilters(newFilters);\n      invalidateQueries([\"approvals\", newFilters]);\n    },\n    getApproval,\n    approve: (approvalId, comment) =>\n      approveMutation.mutateAsync({ approvalId, comment }),\n    reject: (approvalId, comment) =>\n      rejectMutation.mutateAsync({ approvalId, comment }),\n    forward: (approvalId, toEmployeeId, comment) =>\n      forwardMutation.mutateAsync({ approvalId, toEmployeeId, comment }),\n    requestApproval: requestMutation.mutateAsync,\n    refresh: refetch,\n  };\n}\n","/**\n * Spending Limits Hook\n *\n * Provides access to B2B spending limits and budget tracking.\n */\n\nimport { useState, useMemo, useCallback } from \"react\";\nimport type { SpendingLimit, SpendingPeriod } from \"@maison/types\";\nimport { useApiQuery } from \"../api/useApiQuery\";\n\n/**\n * Spending summary for a specific period\n */\nexport interface SpendingSummary {\n  /** Spending limit for the period */\n  limit: number;\n  /** Amount spent in current period */\n  spent: number;\n  /** Remaining budget */\n  remaining: number;\n  /** Percentage of limit used */\n  percentageUsed: number;\n  /** Whether limit is exceeded */\n  isExceeded: boolean;\n  /** Whether approaching limit (warning threshold) */\n  isWarning: boolean;\n  /** Period start date */\n  periodStart: string;\n  /** Period end date */\n  periodEnd: string;\n}\n\n/**\n * Spending hook result\n */\nexport interface UseSpendingLimitsResult {\n  /** All spending limits for the employee */\n  limits: SpendingLimit[];\n  /** Spending summaries by period */\n  summaries: {\n    perOrder: SpendingSummary | null;\n    daily: SpendingSummary | null;\n    weekly: SpendingSummary | null;\n    monthly: SpendingSummary | null;\n  };\n  /** Loading state */\n  isLoading: boolean;\n  /** Error if any */\n  error: Error | null;\n  /** Check if an amount would exceed limits */\n  canSpend: (amount: number) => { allowed: boolean; reason?: string };\n  /** Get spending history */\n  getHistory: (period: SpendingPeriod) => Promise<SpendingHistoryEntry[]>;\n  /** Refresh spending data */\n  refresh: () => void;\n}\n\n/**\n * Spending history entry\n */\nexport interface SpendingHistoryEntry {\n  /** Entry ID */\n  id: string;\n  /** Order/quote ID */\n  entityId: string;\n  /** Entity type */\n  entityType: \"order\" | \"quote\";\n  /** Amount spent */\n  amount: number;\n  /** Timestamp */\n  createdAt: string;\n  /** Description */\n  description?: string;\n}\n\n/**\n * Hook for managing B2B spending limits\n *\n * @param api - API client instance\n * @param employeeId - Employee ID (optional, uses current employee)\n * @returns Spending limits state and utilities\n *\n * @example\n * ```typescript\n * const { summaries, canSpend, refresh } = useSpendingLimits(api);\n *\n * // Check before placing order\n * const { allowed, reason } = canSpend(orderTotal);\n * if (!allowed) {\n *   showError(reason);\n * }\n *\n * // Display spending meter\n * const monthly = summaries.monthly;\n * if (monthly) {\n *   <SpendingMeter percentage={monthly.percentageUsed} warning={monthly.isWarning} />\n * }\n * ```\n */\nexport function useSpendingLimits(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  api: any, // ICommerceClient\n  employeeId?: string\n): UseSpendingLimitsResult {\n  // Query for spending limits\n  const {\n    data: limits,\n    isLoading,\n    error,\n    refetch,\n  } = useApiQuery<SpendingLimit[]>(\n    [\"spending-limits\", employeeId],\n    async () => {\n      if (!api?.b2b?.spending) {\n        return [];\n      }\n      const context = api.getB2BContext?.();\n      const targetEmployeeId = employeeId ?? context?.employeeId;\n      if (!targetEmployeeId) {\n        return [];\n      }\n      const result = await api.b2b.spending.getLimits(targetEmployeeId);\n      // Normalize to array\n      return Array.isArray(result) ? result : result?.items ?? [result].filter(Boolean);\n    },\n    {\n      enabled: !!api?.b2b?.spending,\n      staleTime: 60000, // 1 minute\n    }\n  );\n\n  // Helper to find limit by period\n  const findLimitByPeriod = useCallback(\n    (period: SpendingPeriod): SpendingLimit | null => {\n      return (limits ?? []).find((l) => l.period === period && l.isActive) ?? null;\n    },\n    [limits]\n  );\n\n  // Helper to create summary from a SpendingLimit\n  const createSummaryFromLimit = useCallback(\n    (limit: SpendingLimit | null): SpendingSummary | null => {\n      if (!limit) {\n        return null;\n      }\n\n      return {\n        limit: limit.limitAmount,\n        spent: limit.currentSpending,\n        remaining: limit.remainingAmount,\n        percentageUsed: limit.percentageUsed,\n        isExceeded: limit.isExceeded,\n        isWarning: limit.isWarning,\n        periodStart: limit.lastResetAt,\n        periodEnd: limit.nextResetAt,\n      };\n    },\n    []\n  );\n\n  // Calculate summaries from limits\n  const summaries = useMemo(() => {\n    return {\n      perOrder: createSummaryFromLimit(findLimitByPeriod(\"per_order\")),\n      daily: createSummaryFromLimit(findLimitByPeriod(\"daily\")),\n      weekly: createSummaryFromLimit(findLimitByPeriod(\"weekly\")),\n      monthly: createSummaryFromLimit(findLimitByPeriod(\"monthly\")),\n    };\n  }, [findLimitByPeriod, createSummaryFromLimit]);\n\n  // Check if amount can be spent\n  const canSpend = useCallback(\n    (amount: number): { allowed: boolean; reason?: string } => {\n      if (!limits || limits.length === 0) {\n        return { allowed: true }; // No limits configured\n      }\n\n      // Check per-order limit\n      const perOrderLimit = findLimitByPeriod(\"per_order\");\n      if (perOrderLimit && amount > perOrderLimit.limitAmount) {\n        return {\n          allowed: false,\n          reason: `Order amount (€${amount.toFixed(2)}) exceeds per-order limit (€${perOrderLimit.limitAmount.toFixed(2)})`,\n        };\n      }\n\n      // Check daily limit\n      const dailyLimit = findLimitByPeriod(\"daily\");\n      if (dailyLimit && dailyLimit.currentSpending + amount > dailyLimit.limitAmount) {\n        return {\n          allowed: false,\n          reason: `This order would exceed your daily spending limit (€${dailyLimit.limitAmount.toFixed(2)})`,\n        };\n      }\n\n      // Check weekly limit\n      const weeklyLimit = findLimitByPeriod(\"weekly\");\n      if (weeklyLimit && weeklyLimit.currentSpending + amount > weeklyLimit.limitAmount) {\n        return {\n          allowed: false,\n          reason: `This order would exceed your weekly spending limit (€${weeklyLimit.limitAmount.toFixed(2)})`,\n        };\n      }\n\n      // Check monthly limit\n      const monthlyLimit = findLimitByPeriod(\"monthly\");\n      if (monthlyLimit && monthlyLimit.currentSpending + amount > monthlyLimit.limitAmount) {\n        return {\n          allowed: false,\n          reason: `This order would exceed your monthly spending limit (€${monthlyLimit.limitAmount.toFixed(2)})`,\n        };\n      }\n\n      return { allowed: true };\n    },\n    [limits, findLimitByPeriod]\n  );\n\n  // Get spending history\n  const getHistory = useCallback(\n    async (period: SpendingPeriod): Promise<SpendingHistoryEntry[]> => {\n      if (!api?.b2b?.spending) {\n        return [];\n      }\n      const context = api.getB2BContext?.();\n      const targetEmployeeId = employeeId ?? context?.employeeId;\n      if (!targetEmployeeId) {\n        return [];\n      }\n      return api.b2b.spending.getHistory(targetEmployeeId, period);\n    },\n    [api, employeeId]\n  );\n\n  return {\n    limits: limits ?? [],\n    summaries,\n    isLoading,\n    error,\n    canSpend,\n    getHistory,\n    refresh: refetch,\n  };\n}\n","/**\n * Cart Hook\n *\n * Provides unified cart management for web and mobile.\n */\n\nimport { useState, useCallback, useMemo, useEffect } from \"react\";\nimport type { Cart, CartItem } from \"@maison/types\";\nimport { useApiQuery, invalidateQueries } from \"../api/useApiQuery\";\nimport { useApiMutation } from \"../api/useApiMutation\";\n\n/**\n * Extended cart item with ID for API operations\n */\nexport interface CartItemWithId extends CartItem {\n  /** Unique item ID for cart operations */\n  id?: string;\n  /** Product ID reference */\n  productId?: string;\n  /** Variant ID if applicable */\n  variantId?: string;\n}\n\n/**\n * Extended cart with additional fields\n */\nexport interface ExtendedCart extends Cart {\n  /** Cart ID */\n  id?: string;\n  /** Subtotal (before taxes/discounts) */\n  subtotal?: number;\n  /** Total (with taxes/discounts) */\n  total?: number;\n  /** Extended items with IDs */\n  items: CartItemWithId[];\n}\n\n/**\n * Cart update input\n */\nexport interface CartUpdateInput {\n  /** Product or variant ID */\n  productId: string;\n  /** Quantity to add/update */\n  quantity: number;\n  /** Variant ID if applicable */\n  variantId?: string;\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Cart hook options\n */\nexport interface UseCartOptions {\n  /** Cart ID (optional, will create/retrieve if not provided) */\n  cartId?: string;\n  /** Region ID for pricing */\n  regionId?: string;\n  /** Auto-refresh interval in ms */\n  refreshInterval?: number;\n}\n\n/**\n * Cart hook result\n */\nexport interface UseCartResult {\n  /** Current cart */\n  cart: ExtendedCart | null;\n  /** Cart items */\n  items: CartItemWithId[];\n  /** Total items count */\n  itemCount: number;\n  /** Cart subtotal */\n  subtotal: number;\n  /** Cart total (with taxes/discounts) */\n  total: number;\n  /** Loading state */\n  isLoading: boolean;\n  /** Error if any */\n  error: Error | null;\n  /** Whether cart is empty */\n  isEmpty: boolean;\n  /** Add item to cart */\n  addItem: (input: CartUpdateInput) => Promise<ExtendedCart>;\n  /** Update item quantity */\n  updateItem: (itemId: string, quantity: number) => Promise<ExtendedCart>;\n  /** Remove item from cart */\n  removeItem: (itemId: string) => Promise<ExtendedCart>;\n  /** Clear entire cart */\n  clearCart: () => Promise<void>;\n  /** Apply discount code */\n  applyDiscount: (code: string) => Promise<ExtendedCart>;\n  /** Remove discount code */\n  removeDiscount: (code: string) => Promise<ExtendedCart>;\n  /** Refresh cart data */\n  refresh: () => void;\n}\n\n/**\n * Hook for managing shopping cart\n *\n * @param api - API client instance\n * @param options - Hook options\n * @returns Cart state and actions\n *\n * @example\n * ```typescript\n * const {\n *   cart,\n *   items,\n *   total,\n *   addItem,\n *   removeItem,\n *   clearCart\n * } = useCart(api, { regionId: 'reg_123' });\n *\n * // Add item\n * await addItem({ productId: 'prod_123', quantity: 2 });\n *\n * // Update quantity\n * await updateItem('item_123', 5);\n * ```\n */\nexport function useCart(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  api: any, // ICommerceClient\n  options: UseCartOptions = {}\n): UseCartResult {\n  const { cartId: initialCartId, regionId, refreshInterval } = options;\n  const [cartId, setCartId] = useState<string | undefined>(initialCartId);\n\n  // Query for cart\n  const {\n    data: cart,\n    isLoading,\n    error,\n    refetch,\n  } = useApiQuery<ExtendedCart | null>(\n    [\"cart\", cartId],\n    async () => {\n      if (!api?.cart) {\n        return null;\n      }\n\n      // If we have a cart ID, retrieve it\n      if (cartId) {\n        try {\n          return await api.cart.get(cartId);\n        } catch {\n          // Cart not found, create new one\n        }\n      }\n\n      // Create a new cart\n      const newCart = await api.cart.create({ regionId });\n      setCartId(newCart.id);\n      return newCart;\n    },\n    {\n      enabled: !!api?.cart,\n      staleTime: 30000, // 30 seconds\n    }\n  );\n\n  // Auto-refresh interval\n  useEffect(() => {\n    if (!refreshInterval || !api?.cart) return;\n\n    const interval = setInterval(() => {\n      refetch();\n    }, refreshInterval);\n\n    return () => clearInterval(interval);\n  }, [refreshInterval, api, refetch]);\n\n  // Derived state\n  const items = useMemo(() => (cart?.items ?? []) as CartItemWithId[], [cart]);\n  const itemCount = useMemo(\n    () => cart?.totalItems ?? items.reduce((sum, item) => sum + item.quantity, 0),\n    [cart, items]\n  );\n  // Use subtotal if available, otherwise calculate from items or use totalPrice\n  const subtotal = useMemo(() => {\n    if (cart?.subtotal !== undefined) return cart.subtotal;\n    // Fallback to totalPrice or calculate from items\n    return cart?.totalPrice ?? 0;\n  }, [cart]);\n  // Use total if available, otherwise use totalPrice\n  const total = useMemo(() => cart?.total ?? cart?.totalPrice ?? 0, [cart]);\n  const isEmpty = items.length === 0;\n\n  // Helper to get item ID\n  const getItemId = (item: CartItemWithId, index: number): string => {\n    return item.id ?? item.productId ?? item.product?.id ?? `item-${index}`;\n  };\n\n  // Add item mutation\n  const addItemMutation = useApiMutation<ExtendedCart, CartUpdateInput>(\n    async (input) => {\n      if (!api?.cart || !cartId) {\n        throw new Error(\"Cart not available\");\n      }\n      return api.cart.addItem(cartId, {\n        productId: input.productId,\n        variantId: input.variantId,\n        quantity: input.quantity,\n        metadata: input.metadata,\n      });\n    },\n    {\n      invalidateKeys: [[\"cart\", cartId]],\n    }\n  );\n\n  // Update item mutation\n  const updateItemMutation = useApiMutation<\n    ExtendedCart,\n    { itemId: string; quantity: number }\n  >(\n    async ({ itemId, quantity }) => {\n      if (!api?.cart || !cartId) {\n        throw new Error(\"Cart not available\");\n      }\n      return api.cart.updateItem(cartId, itemId, { quantity });\n    },\n    {\n      invalidateKeys: [[\"cart\", cartId]],\n    }\n  );\n\n  // Remove item mutation\n  const removeItemMutation = useApiMutation<ExtendedCart, string>(\n    async (itemId) => {\n      if (!api?.cart || !cartId) {\n        throw new Error(\"Cart not available\");\n      }\n      return api.cart.removeItem(cartId, itemId);\n    },\n    {\n      invalidateKeys: [[\"cart\", cartId]],\n    }\n  );\n\n  // Clear cart mutation\n  const clearCartMutation = useApiMutation<void, void>(\n    async () => {\n      if (!api?.cart || !cartId) {\n        throw new Error(\"Cart not available\");\n      }\n      // Remove all items\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        const itemId = getItemId(item, i);\n        await api.cart.removeItem(cartId, itemId);\n      }\n    },\n    {\n      invalidateKeys: [[\"cart\", cartId]],\n    }\n  );\n\n  // Apply discount mutation\n  const applyDiscountMutation = useApiMutation<ExtendedCart, string>(\n    async (code) => {\n      if (!api?.cart || !cartId) {\n        throw new Error(\"Cart not available\");\n      }\n      return api.cart.applyDiscount(cartId, code);\n    },\n    {\n      invalidateKeys: [[\"cart\", cartId]],\n    }\n  );\n\n  // Remove discount mutation\n  const removeDiscountMutation = useApiMutation<ExtendedCart, string>(\n    async (code) => {\n      if (!api?.cart || !cartId) {\n        throw new Error(\"Cart not available\");\n      }\n      return api.cart.removeDiscount(cartId, code);\n    },\n    {\n      invalidateKeys: [[\"cart\", cartId]],\n    }\n  );\n\n  return {\n    cart,\n    items,\n    itemCount,\n    subtotal,\n    total,\n    isLoading,\n    error,\n    isEmpty,\n    addItem: addItemMutation.mutateAsync,\n    updateItem: (itemId, quantity) =>\n      updateItemMutation.mutateAsync({ itemId, quantity }),\n    removeItem: removeItemMutation.mutateAsync,\n    clearCart: clearCartMutation.mutateAsync,\n    applyDiscount: applyDiscountMutation.mutateAsync,\n    removeDiscount: removeDiscountMutation.mutateAsync,\n    refresh: refetch,\n  };\n}\n","/**\n * Bulk Cart Hook\n *\n * Provides bulk operations for B2B cart management.\n */\n\nimport { useState, useCallback } from \"react\";\nimport type { Cart } from \"@maison/types\";\nimport { useApiMutation } from \"../api/useApiMutation\";\nimport { invalidateQueries } from \"../api/useApiQuery\";\nimport type { ExtendedCart, CartItemWithId } from \"./useCart\";\n\n/**\n * Bulk item input\n */\nexport interface BulkItemInput {\n  /** Product ID */\n  productId: string;\n  /** Variant ID if applicable */\n  variantId?: string;\n  /** Quantity */\n  quantity: number;\n  /** SKU for quick reference */\n  sku?: string;\n}\n\n/**\n * CSV import result\n */\nexport interface CSVImportResult {\n  /** Successfully added items */\n  added: BulkItemInput[];\n  /** Failed items with reasons */\n  failed: Array<{ item: BulkItemInput; reason: string }>;\n  /** Skipped items (duplicates, etc.) */\n  skipped: BulkItemInput[];\n}\n\n/**\n * Bulk cart hook options\n */\nexport interface UseBulkCartOptions {\n  /** Cart ID */\n  cartId: string;\n  /** Max items per batch */\n  batchSize?: number;\n  /** Validate items before adding */\n  validateBeforeAdd?: boolean;\n}\n\n/**\n * Bulk cart hook result\n */\nexport interface UseBulkCartResult {\n  /** Add multiple items at once */\n  addBulkItems: (items: BulkItemInput[]) => Promise<CSVImportResult>;\n  /** Import from CSV string */\n  importFromCSV: (csvContent: string) => Promise<CSVImportResult>;\n  /** Clear and replace cart contents */\n  replaceCart: (items: BulkItemInput[]) => Promise<ExtendedCart>;\n  /** Duplicate items (e.g., from previous order) */\n  duplicateFromOrder: (orderId: string) => Promise<ExtendedCart>;\n  /** Loading state */\n  isProcessing: boolean;\n  /** Progress for bulk operations */\n  progress: { current: number; total: number };\n  /** Last error */\n  error: Error | null;\n}\n\n/**\n * Parse CSV content into bulk items\n */\nfunction parseCSV(content: string): BulkItemInput[] {\n  const lines = content.trim().split(\"\\n\");\n  if (lines.length < 2) return [];\n\n  const header = lines[0].toLowerCase().split(\",\").map((h) => h.trim());\n  const skuIndex = header.findIndex((h) => h === \"sku\" || h === \"reference\");\n  const productIdIndex = header.findIndex((h) => h === \"productid\" || h === \"product_id\" || h === \"id\");\n  const variantIdIndex = header.findIndex((h) => h === \"variantid\" || h === \"variant_id\" || h === \"variant\");\n  const quantityIndex = header.findIndex((h) => h === \"quantity\" || h === \"qty\" || h === \"quantite\");\n\n  if (quantityIndex === -1) {\n    throw new Error(\"CSV must contain a quantity column\");\n  }\n  if (skuIndex === -1 && productIdIndex === -1) {\n    throw new Error(\"CSV must contain a sku or productId column\");\n  }\n\n  const items: BulkItemInput[] = [];\n  for (let i = 1; i < lines.length; i++) {\n    const values = lines[i].split(\",\").map((v) => v.trim());\n    const quantity = parseInt(values[quantityIndex], 10);\n\n    if (isNaN(quantity) || quantity <= 0) continue;\n\n    items.push({\n      productId: productIdIndex >= 0 ? values[productIdIndex] : \"\",\n      sku: skuIndex >= 0 ? values[skuIndex] : undefined,\n      variantId: variantIdIndex >= 0 ? values[variantIdIndex] : undefined,\n      quantity,\n    });\n  }\n\n  return items;\n}\n\n/**\n * Hook for bulk cart operations in B2B context\n *\n * @param api - API client instance\n * @param options - Hook options\n * @returns Bulk cart actions and state\n *\n * @example\n * ```typescript\n * const {\n *   addBulkItems,\n *   importFromCSV,\n *   duplicateFromOrder,\n *   isProcessing,\n *   progress\n * } = useBulkCart(api, { cartId: 'cart_123' });\n *\n * // Add multiple items\n * const result = await addBulkItems([\n *   { productId: 'prod_1', quantity: 10 },\n *   { productId: 'prod_2', quantity: 5 },\n * ]);\n *\n * // Import from CSV\n * const csvResult = await importFromCSV(csvFileContent);\n * ```\n */\nexport function useBulkCart(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  api: any, // ICommerceClient\n  options: UseBulkCartOptions\n): UseBulkCartResult {\n  const { cartId, batchSize = 10, validateBeforeAdd = true } = options;\n\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [progress, setProgress] = useState({ current: 0, total: 0 });\n  const [error, setError] = useState<Error | null>(null);\n\n  const addBulkItems = useCallback(\n    async (items: BulkItemInput[]): Promise<CSVImportResult> => {\n      if (!api?.cart) {\n        throw new Error(\"Cart API not available\");\n      }\n\n      setIsProcessing(true);\n      setError(null);\n      setProgress({ current: 0, total: items.length });\n\n      const result: CSVImportResult = {\n        added: [],\n        failed: [],\n        skipped: [],\n      };\n\n      // Process in batches\n      for (let i = 0; i < items.length; i += batchSize) {\n        const batch = items.slice(i, i + batchSize);\n\n        await Promise.all(\n          batch.map(async (item) => {\n            try {\n              // Resolve SKU to product ID if needed\n              let productId = item.productId;\n              if (!productId && item.sku && api.products?.findBySku) {\n                const product = await api.products.findBySku(item.sku);\n                if (product) {\n                  productId = product.id;\n                }\n              }\n\n              if (!productId) {\n                result.failed.push({\n                  item,\n                  reason: \"Product not found\",\n                });\n                return;\n              }\n\n              // Validate stock if enabled\n              if (validateBeforeAdd && api.products?.getInventory) {\n                const inventory = await api.products.getInventory(productId);\n                if (inventory.available < item.quantity) {\n                  result.failed.push({\n                    item,\n                    reason: `Insufficient stock: ${inventory.available} available`,\n                  });\n                  return;\n                }\n              }\n\n              // Add to cart\n              await api.cart.addItem(cartId, {\n                productId,\n                variantId: item.variantId,\n                quantity: item.quantity,\n              });\n\n              result.added.push(item);\n            } catch (err) {\n              result.failed.push({\n                item,\n                reason: err instanceof Error ? err.message : \"Unknown error\",\n              });\n            }\n          })\n        );\n\n        setProgress({ current: Math.min(i + batchSize, items.length), total: items.length });\n      }\n\n      invalidateQueries([\"cart\", cartId]);\n      setIsProcessing(false);\n\n      return result;\n    },\n    [api, cartId, batchSize, validateBeforeAdd]\n  );\n\n  const importFromCSV = useCallback(\n    async (csvContent: string): Promise<CSVImportResult> => {\n      try {\n        const items = parseCSV(csvContent);\n        if (items.length === 0) {\n          throw new Error(\"No valid items found in CSV\");\n        }\n        return addBulkItems(items);\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error(String(err)));\n        throw err;\n      }\n    },\n    [addBulkItems]\n  );\n\n  const replaceCart = useCallback(\n    async (items: BulkItemInput[]): Promise<ExtendedCart> => {\n      if (!api?.cart) {\n        throw new Error(\"Cart API not available\");\n      }\n\n      setIsProcessing(true);\n      setError(null);\n\n      try {\n        // Get current cart and clear it\n        const currentCart = await api.cart.get(cartId);\n        for (let i = 0; i < currentCart.items.length; i++) {\n          const item = currentCart.items[i] as CartItemWithId;\n          const itemId = item.id ?? item.productId ?? item.product?.id ?? `item-${i}`;\n          await api.cart.removeItem(cartId, itemId);\n        }\n\n        // Add new items\n        await addBulkItems(items);\n\n        // Return updated cart\n        const updatedCart = await api.cart.get(cartId);\n        setIsProcessing(false);\n        return updatedCart;\n      } catch (err) {\n        setIsProcessing(false);\n        setError(err instanceof Error ? err : new Error(String(err)));\n        throw err;\n      }\n    },\n    [api, cartId, addBulkItems]\n  );\n\n  const duplicateFromOrder = useCallback(\n    async (orderId: string): Promise<ExtendedCart> => {\n      if (!api?.cart || !api?.orders) {\n        throw new Error(\"Cart or Orders API not available\");\n      }\n\n      setIsProcessing(true);\n      setError(null);\n\n      try {\n        // Get order items\n        const order = await api.orders.get(orderId);\n\n        // Convert to bulk items\n        const items: BulkItemInput[] = order.items.map((item: CartItemWithId) => ({\n          productId: item.productId ?? item.product?.id ?? \"\",\n          variantId: item.variantId,\n          quantity: item.quantity,\n        }));\n\n        // Add to cart\n        await addBulkItems(items);\n\n        // Return updated cart\n        const updatedCart = await api.cart.get(cartId);\n        setIsProcessing(false);\n        return updatedCart;\n      } catch (err) {\n        setIsProcessing(false);\n        setError(err instanceof Error ? err : new Error(String(err)));\n        throw err;\n      }\n    },\n    [api, cartId, addBulkItems]\n  );\n\n  return {\n    addBulkItems,\n    importFromCSV,\n    replaceCart,\n    duplicateFromOrder,\n    isProcessing,\n    progress,\n    error,\n  };\n}\n","/**\n * Storage Hook\n *\n * Platform-agnostic storage abstraction for web and mobile.\n */\n\nimport { useState, useEffect, useCallback } from \"react\";\n\n/**\n * Storage adapter interface\n */\nexport interface StorageAdapter {\n  /** Get item from storage */\n  getItem: (key: string) => Promise<string | null> | string | null;\n  /** Set item in storage */\n  setItem: (key: string, value: string) => Promise<void> | void;\n  /** Remove item from storage */\n  removeItem: (key: string) => Promise<void> | void;\n}\n\n/**\n * Default web storage adapter\n */\nconst webStorageAdapter: StorageAdapter = {\n  getItem: (key) => {\n    if (typeof window === \"undefined\") return null;\n    return localStorage.getItem(key);\n  },\n  setItem: (key, value) => {\n    if (typeof window !== \"undefined\") {\n      localStorage.setItem(key, value);\n    }\n  },\n  removeItem: (key) => {\n    if (typeof window !== \"undefined\") {\n      localStorage.removeItem(key);\n    }\n  },\n};\n\n/**\n * Global storage adapter - can be overridden for React Native\n */\nlet globalStorageAdapter: StorageAdapter = webStorageAdapter;\n\n/**\n * Set the global storage adapter\n *\n * @param adapter - Storage adapter to use\n *\n * @example\n * ```typescript\n * // In React Native app initialization\n * import AsyncStorage from '@react-native-async-storage/async-storage';\n *\n * setStorageAdapter({\n *   getItem: AsyncStorage.getItem,\n *   setItem: AsyncStorage.setItem,\n *   removeItem: AsyncStorage.removeItem,\n * });\n * ```\n */\nexport function setStorageAdapter(adapter: StorageAdapter): void {\n  globalStorageAdapter = adapter;\n}\n\n/**\n * Storage hook options\n */\nexport interface UseStorageOptions<T> {\n  /** Serializer function (default: JSON.stringify) */\n  serialize?: (value: T) => string;\n  /** Deserializer function (default: JSON.parse) */\n  deserialize?: (value: string) => T;\n  /** Custom storage adapter */\n  storage?: StorageAdapter;\n}\n\n/**\n * Storage hook result\n */\nexport interface UseStorageResult<T> {\n  /** Current value */\n  value: T;\n  /** Set value */\n  setValue: (value: T | ((prev: T) => T)) => void;\n  /** Remove value from storage */\n  remove: () => void;\n  /** Loading state (for async storage) */\n  isLoading: boolean;\n  /** Error if any */\n  error: Error | null;\n}\n\n/**\n * Hook for persisted storage (localStorage/AsyncStorage)\n *\n * @param key - Storage key\n * @param defaultValue - Default value if not found\n * @param options - Hook options\n * @returns Storage state and actions\n *\n * @example\n * ```typescript\n * // Simple usage\n * const { value, setValue } = useStorage('user-preferences', { theme: 'light' });\n *\n * // Update value\n * setValue({ theme: 'dark' });\n *\n * // Update with callback\n * setValue(prev => ({ ...prev, theme: 'dark' }));\n * ```\n */\nexport function useStorage<T>(\n  key: string,\n  defaultValue: T,\n  options: UseStorageOptions<T> = {}\n): UseStorageResult<T> {\n  const {\n    serialize = JSON.stringify,\n    deserialize = JSON.parse,\n    storage = globalStorageAdapter,\n  } = options;\n\n  const [value, setValueState] = useState<T>(defaultValue);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Load initial value\n  useEffect(() => {\n    const loadValue = async () => {\n      try {\n        setIsLoading(true);\n        const stored = await storage.getItem(key);\n        if (stored !== null) {\n          setValueState(deserialize(stored));\n        }\n        setError(null);\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error(String(err)));\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    loadValue();\n  }, [key, storage, deserialize]);\n\n  // Set value\n  const setValue = useCallback(\n    (newValue: T | ((prev: T) => T)) => {\n      setValueState((prev) => {\n        const resolvedValue =\n          typeof newValue === \"function\"\n            ? (newValue as (prev: T) => T)(prev)\n            : newValue;\n\n        // Save to storage\n        try {\n          storage.setItem(key, serialize(resolvedValue));\n          setError(null);\n        } catch (err) {\n          setError(err instanceof Error ? err : new Error(String(err)));\n        }\n\n        return resolvedValue;\n      });\n    },\n    [key, storage, serialize]\n  );\n\n  // Remove value\n  const remove = useCallback(() => {\n    try {\n      storage.removeItem(key);\n      setValueState(defaultValue);\n      setError(null);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error(String(err)));\n    }\n  }, [key, storage, defaultValue]);\n\n  return {\n    value,\n    setValue,\n    remove,\n    isLoading,\n    error,\n  };\n}\n\n/**\n * Hook for session storage (web only, memory fallback on mobile)\n */\nexport function useSessionStorage<T>(\n  key: string,\n  defaultValue: T,\n  options: UseStorageOptions<T> = {}\n): UseStorageResult<T> {\n  // In-memory fallback for SSR/mobile\n  const memoryStorage = new Map<string, string>();\n\n  const sessionAdapter: StorageAdapter = {\n    getItem: (k) => {\n      if (typeof window !== \"undefined\" && window.sessionStorage) {\n        return sessionStorage.getItem(k);\n      }\n      return memoryStorage.get(k) ?? null;\n    },\n    setItem: (k, v) => {\n      if (typeof window !== \"undefined\" && window.sessionStorage) {\n        sessionStorage.setItem(k, v);\n      } else {\n        memoryStorage.set(k, v);\n      }\n    },\n    removeItem: (k) => {\n      if (typeof window !== \"undefined\" && window.sessionStorage) {\n        sessionStorage.removeItem(k);\n      } else {\n        memoryStorage.delete(k);\n      }\n    },\n  };\n\n  return useStorage(key, defaultValue, {\n    ...options,\n    storage: sessionAdapter,\n  });\n}\n"],"mappings":"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","names":["import_react","import_react","import_react","import_react","import_react","import_react","import_react","import_react"]}