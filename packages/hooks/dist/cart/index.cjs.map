{"version":3,"sources":["../../src/cart/index.ts","../../src/cart/useCart.ts","../../src/api/useApiQuery.ts","../../src/api/useApiMutation.ts","../../src/cart/useBulkCart.ts"],"sourcesContent":["/**\n * Cart Hooks\n *\n * React hooks for cart management.\n */\n\nexport {\n  useCart,\n  type CartItemWithId,\n  type ExtendedCart,\n  type CartUpdateInput,\n  type UseCartOptions,\n  type UseCartResult,\n} from \"./useCart\";\n\nexport {\n  useBulkCart,\n  type BulkItemInput,\n  type CSVImportResult,\n  type UseBulkCartOptions,\n  type UseBulkCartResult,\n} from \"./useBulkCart\";\n","/**\n * Cart Hook\n *\n * Provides unified cart management for web and mobile.\n */\n\nimport { useState, useCallback, useMemo, useEffect } from \"react\";\nimport type { Cart, CartItem } from \"@maison/types\";\nimport { useApiQuery, invalidateQueries } from \"../api/useApiQuery\";\nimport { useApiMutation } from \"../api/useApiMutation\";\n\n/**\n * Extended cart item with ID for API operations\n */\nexport interface CartItemWithId extends CartItem {\n  /** Unique item ID for cart operations */\n  id?: string;\n  /** Product ID reference */\n  productId?: string;\n  /** Variant ID if applicable */\n  variantId?: string;\n}\n\n/**\n * Extended cart with additional fields\n */\nexport interface ExtendedCart extends Cart {\n  /** Cart ID */\n  id?: string;\n  /** Subtotal (before taxes/discounts) */\n  subtotal?: number;\n  /** Total (with taxes/discounts) */\n  total?: number;\n  /** Extended items with IDs */\n  items: CartItemWithId[];\n}\n\n/**\n * Cart update input\n */\nexport interface CartUpdateInput {\n  /** Product or variant ID */\n  productId: string;\n  /** Quantity to add/update */\n  quantity: number;\n  /** Variant ID if applicable */\n  variantId?: string;\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Cart hook options\n */\nexport interface UseCartOptions {\n  /** Cart ID (optional, will create/retrieve if not provided) */\n  cartId?: string;\n  /** Region ID for pricing */\n  regionId?: string;\n  /** Auto-refresh interval in ms */\n  refreshInterval?: number;\n}\n\n/**\n * Cart hook result\n */\nexport interface UseCartResult {\n  /** Current cart */\n  cart: ExtendedCart | null;\n  /** Cart items */\n  items: CartItemWithId[];\n  /** Total items count */\n  itemCount: number;\n  /** Cart subtotal */\n  subtotal: number;\n  /** Cart total (with taxes/discounts) */\n  total: number;\n  /** Loading state */\n  isLoading: boolean;\n  /** Error if any */\n  error: Error | null;\n  /** Whether cart is empty */\n  isEmpty: boolean;\n  /** Add item to cart */\n  addItem: (input: CartUpdateInput) => Promise<ExtendedCart>;\n  /** Update item quantity */\n  updateItem: (itemId: string, quantity: number) => Promise<ExtendedCart>;\n  /** Remove item from cart */\n  removeItem: (itemId: string) => Promise<ExtendedCart>;\n  /** Clear entire cart */\n  clearCart: () => Promise<void>;\n  /** Apply discount code */\n  applyDiscount: (code: string) => Promise<ExtendedCart>;\n  /** Remove discount code */\n  removeDiscount: (code: string) => Promise<ExtendedCart>;\n  /** Refresh cart data */\n  refresh: () => void;\n}\n\n/**\n * Hook for managing shopping cart\n *\n * @param api - API client instance\n * @param options - Hook options\n * @returns Cart state and actions\n *\n * @example\n * ```typescript\n * const {\n *   cart,\n *   items,\n *   total,\n *   addItem,\n *   removeItem,\n *   clearCart\n * } = useCart(api, { regionId: 'reg_123' });\n *\n * // Add item\n * await addItem({ productId: 'prod_123', quantity: 2 });\n *\n * // Update quantity\n * await updateItem('item_123', 5);\n * ```\n */\nexport function useCart(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  api: any, // ICommerceClient\n  options: UseCartOptions = {}\n): UseCartResult {\n  const { cartId: initialCartId, regionId, refreshInterval } = options;\n  const [cartId, setCartId] = useState<string | undefined>(initialCartId);\n\n  // Query for cart\n  const {\n    data: cart,\n    isLoading,\n    error,\n    refetch,\n  } = useApiQuery<ExtendedCart | null>(\n    [\"cart\", cartId],\n    async () => {\n      if (!api?.cart) {\n        return null;\n      }\n\n      // If we have a cart ID, retrieve it\n      if (cartId) {\n        try {\n          return await api.cart.get(cartId);\n        } catch {\n          // Cart not found, create new one\n        }\n      }\n\n      // Create a new cart\n      const newCart = await api.cart.create({ regionId });\n      setCartId(newCart.id);\n      return newCart;\n    },\n    {\n      enabled: !!api?.cart,\n      staleTime: 30000, // 30 seconds\n    }\n  );\n\n  // Auto-refresh interval\n  useEffect(() => {\n    if (!refreshInterval || !api?.cart) return;\n\n    const interval = setInterval(() => {\n      refetch();\n    }, refreshInterval);\n\n    return () => clearInterval(interval);\n  }, [refreshInterval, api, refetch]);\n\n  // Derived state\n  const items = useMemo(() => (cart?.items ?? []) as CartItemWithId[], [cart]);\n  const itemCount = useMemo(\n    () => cart?.totalItems ?? items.reduce((sum, item) => sum + item.quantity, 0),\n    [cart, items]\n  );\n  // Use subtotal if available, otherwise calculate from items or use totalPrice\n  const subtotal = useMemo(() => {\n    if (cart?.subtotal !== undefined) return cart.subtotal;\n    // Fallback to totalPrice or calculate from items\n    return cart?.totalPrice ?? 0;\n  }, [cart]);\n  // Use total if available, otherwise use totalPrice\n  const total = useMemo(() => cart?.total ?? cart?.totalPrice ?? 0, [cart]);\n  const isEmpty = items.length === 0;\n\n  // Helper to get item ID\n  const getItemId = (item: CartItemWithId, index: number): string => {\n    return item.id ?? item.productId ?? item.product?.id ?? `item-${index}`;\n  };\n\n  // Add item mutation\n  const addItemMutation = useApiMutation<ExtendedCart, CartUpdateInput>(\n    async (input) => {\n      if (!api?.cart || !cartId) {\n        throw new Error(\"Cart not available\");\n      }\n      return api.cart.addItem(cartId, {\n        productId: input.productId,\n        variantId: input.variantId,\n        quantity: input.quantity,\n        metadata: input.metadata,\n      });\n    },\n    {\n      invalidateKeys: [[\"cart\", cartId]],\n    }\n  );\n\n  // Update item mutation\n  const updateItemMutation = useApiMutation<\n    ExtendedCart,\n    { itemId: string; quantity: number }\n  >(\n    async ({ itemId, quantity }) => {\n      if (!api?.cart || !cartId) {\n        throw new Error(\"Cart not available\");\n      }\n      return api.cart.updateItem(cartId, itemId, { quantity });\n    },\n    {\n      invalidateKeys: [[\"cart\", cartId]],\n    }\n  );\n\n  // Remove item mutation\n  const removeItemMutation = useApiMutation<ExtendedCart, string>(\n    async (itemId) => {\n      if (!api?.cart || !cartId) {\n        throw new Error(\"Cart not available\");\n      }\n      return api.cart.removeItem(cartId, itemId);\n    },\n    {\n      invalidateKeys: [[\"cart\", cartId]],\n    }\n  );\n\n  // Clear cart mutation\n  const clearCartMutation = useApiMutation<void, void>(\n    async () => {\n      if (!api?.cart || !cartId) {\n        throw new Error(\"Cart not available\");\n      }\n      // Remove all items\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        const itemId = getItemId(item, i);\n        await api.cart.removeItem(cartId, itemId);\n      }\n    },\n    {\n      invalidateKeys: [[\"cart\", cartId]],\n    }\n  );\n\n  // Apply discount mutation\n  const applyDiscountMutation = useApiMutation<ExtendedCart, string>(\n    async (code) => {\n      if (!api?.cart || !cartId) {\n        throw new Error(\"Cart not available\");\n      }\n      return api.cart.applyDiscount(cartId, code);\n    },\n    {\n      invalidateKeys: [[\"cart\", cartId]],\n    }\n  );\n\n  // Remove discount mutation\n  const removeDiscountMutation = useApiMutation<ExtendedCart, string>(\n    async (code) => {\n      if (!api?.cart || !cartId) {\n        throw new Error(\"Cart not available\");\n      }\n      return api.cart.removeDiscount(cartId, code);\n    },\n    {\n      invalidateKeys: [[\"cart\", cartId]],\n    }\n  );\n\n  return {\n    cart,\n    items,\n    itemCount,\n    subtotal,\n    total,\n    isLoading,\n    error,\n    isEmpty,\n    addItem: addItemMutation.mutateAsync,\n    updateItem: (itemId, quantity) =>\n      updateItemMutation.mutateAsync({ itemId, quantity }),\n    removeItem: removeItemMutation.mutateAsync,\n    clearCart: clearCartMutation.mutateAsync,\n    applyDiscount: applyDiscountMutation.mutateAsync,\n    removeDiscount: removeDiscountMutation.mutateAsync,\n    refresh: refetch,\n  };\n}\n","/**\n * Generic API Query Hook\n *\n * Provides a reusable hook for fetching data with caching, loading states,\n * and error handling. Works with any async function.\n */\n\nimport { useState, useEffect, useCallback, useRef } from \"react\";\n\n/**\n * Query state\n */\nexport interface QueryState<T> {\n  /** The fetched data */\n  data: T | null;\n  /** Loading state */\n  isLoading: boolean;\n  /** Error if any */\n  error: Error | null;\n  /** Whether data has been fetched at least once */\n  isSuccess: boolean;\n  /** Whether the query is currently fetching (includes refetches) */\n  isFetching: boolean;\n}\n\n/**\n * Query options\n */\nexport interface UseApiQueryOptions<T> {\n  /** Whether to enable the query */\n  enabled?: boolean;\n  /** Initial data */\n  initialData?: T;\n  /** Stale time in ms (default: 0 - always stale) */\n  staleTime?: number;\n  /** Cache time in ms (default: 5 minutes) */\n  cacheTime?: number;\n  /** Retry count (default: 3) */\n  retryCount?: number;\n  /** Retry delay in ms (default: 1000) */\n  retryDelay?: number;\n  /** On success callback */\n  onSuccess?: (data: T) => void;\n  /** On error callback */\n  onError?: (error: Error) => void;\n  /** Refetch on window focus (default: false) */\n  refetchOnWindowFocus?: boolean;\n}\n\n/**\n * Query result\n */\nexport interface UseApiQueryResult<T> extends QueryState<T> {\n  /** Manually refetch the data */\n  refetch: () => Promise<void>;\n  /** Reset the query state */\n  reset: () => void;\n}\n\n// Simple in-memory cache\nconst queryCache = new Map<string, { data: unknown; timestamp: number }>();\n\n/**\n * Generic API query hook\n *\n * @param queryKey - Unique key for the query (used for caching)\n * @param queryFn - Async function to fetch data\n * @param options - Query options\n * @returns Query result with data, loading state, and refetch function\n *\n * @example\n * ```typescript\n * const { data, isLoading, error, refetch } = useApiQuery(\n *   [\"products\", categoryId],\n *   () => api.products.list({ categoryId }),\n *   { staleTime: 60000 }\n * );\n * ```\n */\nexport function useApiQuery<T>(\n  queryKey: unknown[],\n  queryFn: () => Promise<T>,\n  options: UseApiQueryOptions<T> = {}\n): UseApiQueryResult<T> {\n  const {\n    enabled = true,\n    initialData,\n    staleTime = 0,\n    cacheTime = 5 * 60 * 1000,\n    retryCount = 3,\n    retryDelay = 1000,\n    onSuccess,\n    onError,\n    refetchOnWindowFocus = false,\n  } = options;\n\n  const cacheKey = JSON.stringify(queryKey);\n  const retryCountRef = useRef(0);\n\n  const [state, setState] = useState<QueryState<T>>(() => {\n    // Check cache first\n    const cached = queryCache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < cacheTime) {\n      return {\n        data: cached.data as T,\n        isLoading: false,\n        error: null,\n        isSuccess: true,\n        isFetching: false,\n      };\n    }\n\n    return {\n      data: initialData ?? null,\n      isLoading: enabled,\n      error: null,\n      isSuccess: false,\n      isFetching: enabled,\n    };\n  });\n\n  const fetchData = useCallback(\n    async (isRefetch = false) => {\n      if (!isRefetch) {\n        // Check if cached data is still fresh\n        const cached = queryCache.get(cacheKey);\n        if (cached && Date.now() - cached.timestamp < staleTime) {\n          setState((prev) => ({\n            ...prev,\n            data: cached.data as T,\n            isLoading: false,\n            isSuccess: true,\n            isFetching: false,\n          }));\n          return;\n        }\n      }\n\n      setState((prev) => ({\n        ...prev,\n        isLoading: !prev.data,\n        isFetching: true,\n        error: null,\n      }));\n\n      try {\n        const data = await queryFn();\n\n        // Update cache\n        queryCache.set(cacheKey, { data, timestamp: Date.now() });\n\n        setState({\n          data,\n          isLoading: false,\n          error: null,\n          isSuccess: true,\n          isFetching: false,\n        });\n\n        retryCountRef.current = 0;\n        onSuccess?.(data);\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err));\n\n        // Retry logic\n        if (retryCountRef.current < retryCount) {\n          retryCountRef.current++;\n          setTimeout(() => fetchData(isRefetch), retryDelay * retryCountRef.current);\n          return;\n        }\n\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error,\n          isFetching: false,\n        }));\n\n        retryCountRef.current = 0;\n        onError?.(error);\n      }\n    },\n    [cacheKey, queryFn, staleTime, retryCount, retryDelay, onSuccess, onError]\n  );\n\n  const refetch = useCallback(async () => {\n    retryCountRef.current = 0;\n    await fetchData(true);\n  }, [fetchData]);\n\n  const reset = useCallback(() => {\n    queryCache.delete(cacheKey);\n    setState({\n      data: initialData ?? null,\n      isLoading: false,\n      error: null,\n      isSuccess: false,\n      isFetching: false,\n    });\n  }, [cacheKey, initialData]);\n\n  // Initial fetch\n  useEffect(() => {\n    if (enabled) {\n      fetchData();\n    }\n  }, [enabled, cacheKey]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  // Refetch on window focus\n  useEffect(() => {\n    if (!refetchOnWindowFocus || !enabled) return;\n\n    const handleFocus = () => {\n      const cached = queryCache.get(cacheKey);\n      if (!cached || Date.now() - cached.timestamp >= staleTime) {\n        fetchData(true);\n      }\n    };\n\n    window.addEventListener(\"focus\", handleFocus);\n    return () => window.removeEventListener(\"focus\", handleFocus);\n  }, [refetchOnWindowFocus, enabled, cacheKey, staleTime, fetchData]);\n\n  return {\n    ...state,\n    refetch,\n    reset,\n  };\n}\n\n/**\n * Clear the query cache\n */\nexport function clearQueryCache(): void {\n  queryCache.clear();\n}\n\n/**\n * Invalidate specific query keys\n */\nexport function invalidateQueries(queryKey: unknown[]): void {\n  const cacheKey = JSON.stringify(queryKey);\n  queryCache.delete(cacheKey);\n}\n","/**\n * Generic API Mutation Hook\n *\n * Provides a reusable hook for performing mutations (create, update, delete)\n * with loading states, error handling, and optimistic updates.\n */\n\nimport { useState, useCallback } from \"react\";\nimport { invalidateQueries } from \"./useApiQuery\";\n\n/**\n * Mutation state\n */\nexport interface MutationState<TData> {\n  /** The result data */\n  data: TData | null;\n  /** Loading state */\n  isLoading: boolean;\n  /** Error if any */\n  error: Error | null;\n  /** Whether mutation was successful */\n  isSuccess: boolean;\n  /** Whether mutation resulted in error */\n  isError: boolean;\n}\n\n/**\n * Mutation options\n */\nexport interface UseApiMutationOptions<TData, TVariables> {\n  /** On success callback */\n  onSuccess?: (data: TData, variables: TVariables) => void;\n  /** On error callback */\n  onError?: (error: Error, variables: TVariables) => void;\n  /** On settled callback (runs after success or error) */\n  onSettled?: (data: TData | null, error: Error | null, variables: TVariables) => void;\n  /** Query keys to invalidate on success */\n  invalidateKeys?: unknown[][];\n  /** Retry count (default: 0) */\n  retryCount?: number;\n}\n\n/**\n * Mutation result\n */\nexport interface UseApiMutationResult<TData, TVariables> extends MutationState<TData> {\n  /** Execute the mutation */\n  mutate: (variables: TVariables) => void;\n  /** Execute the mutation and return a promise */\n  mutateAsync: (variables: TVariables) => Promise<TData>;\n  /** Reset the mutation state */\n  reset: () => void;\n}\n\n/**\n * Generic API mutation hook\n *\n * @param mutationFn - Async function to perform the mutation\n * @param options - Mutation options\n * @returns Mutation result with mutate function and state\n *\n * @example\n * ```typescript\n * const { mutate, isLoading, error } = useApiMutation(\n *   (input) => api.cart.addItem(cartId, input),\n *   {\n *     onSuccess: () => toast.success('Item added!'),\n *     invalidateKeys: [['cart', cartId]]\n *   }\n * );\n *\n * // Usage\n * mutate({ productId: 'prod_123', quantity: 2 });\n * ```\n */\nexport function useApiMutation<TData, TVariables = void>(\n  mutationFn: (variables: TVariables) => Promise<TData>,\n  options: UseApiMutationOptions<TData, TVariables> = {}\n): UseApiMutationResult<TData, TVariables> {\n  const {\n    onSuccess,\n    onError,\n    onSettled,\n    invalidateKeys = [],\n    retryCount = 0,\n  } = options;\n\n  const [state, setState] = useState<MutationState<TData>>({\n    data: null,\n    isLoading: false,\n    error: null,\n    isSuccess: false,\n    isError: false,\n  });\n\n  const reset = useCallback(() => {\n    setState({\n      data: null,\n      isLoading: false,\n      error: null,\n      isSuccess: false,\n      isError: false,\n    });\n  }, []);\n\n  const mutateAsync = useCallback(\n    async (variables: TVariables): Promise<TData> => {\n      setState({\n        data: null,\n        isLoading: true,\n        error: null,\n        isSuccess: false,\n        isError: false,\n      });\n\n      let lastError: Error | null = null;\n      let attempts = 0;\n\n      while (attempts <= retryCount) {\n        try {\n          const data = await mutationFn(variables);\n\n          setState({\n            data,\n            isLoading: false,\n            error: null,\n            isSuccess: true,\n            isError: false,\n          });\n\n          // Invalidate related queries\n          for (const key of invalidateKeys) {\n            invalidateQueries(key);\n          }\n\n          onSuccess?.(data, variables);\n          onSettled?.(data, null, variables);\n\n          return data;\n        } catch (err) {\n          lastError = err instanceof Error ? err : new Error(String(err));\n          attempts++;\n\n          if (attempts > retryCount) {\n            break;\n          }\n\n          // Wait before retry (exponential backoff)\n          await new Promise((resolve) => setTimeout(resolve, 1000 * attempts));\n        }\n      }\n\n      // All retries failed\n      setState({\n        data: null,\n        isLoading: false,\n        error: lastError,\n        isSuccess: false,\n        isError: true,\n      });\n\n      onError?.(lastError!, variables);\n      onSettled?.(null, lastError, variables);\n\n      throw lastError;\n    },\n    [mutationFn, retryCount, invalidateKeys, onSuccess, onError, onSettled]\n  );\n\n  const mutate = useCallback(\n    (variables: TVariables): void => {\n      mutateAsync(variables).catch(() => {\n        // Error is already handled in state\n      });\n    },\n    [mutateAsync]\n  );\n\n  return {\n    ...state,\n    mutate,\n    mutateAsync,\n    reset,\n  };\n}\n","/**\n * Bulk Cart Hook\n *\n * Provides bulk operations for B2B cart management.\n */\n\nimport { useState, useCallback } from \"react\";\nimport type { Cart } from \"@maison/types\";\nimport { useApiMutation } from \"../api/useApiMutation\";\nimport { invalidateQueries } from \"../api/useApiQuery\";\nimport type { ExtendedCart, CartItemWithId } from \"./useCart\";\n\n/**\n * Bulk item input\n */\nexport interface BulkItemInput {\n  /** Product ID */\n  productId: string;\n  /** Variant ID if applicable */\n  variantId?: string;\n  /** Quantity */\n  quantity: number;\n  /** SKU for quick reference */\n  sku?: string;\n}\n\n/**\n * CSV import result\n */\nexport interface CSVImportResult {\n  /** Successfully added items */\n  added: BulkItemInput[];\n  /** Failed items with reasons */\n  failed: Array<{ item: BulkItemInput; reason: string }>;\n  /** Skipped items (duplicates, etc.) */\n  skipped: BulkItemInput[];\n}\n\n/**\n * Bulk cart hook options\n */\nexport interface UseBulkCartOptions {\n  /** Cart ID */\n  cartId: string;\n  /** Max items per batch */\n  batchSize?: number;\n  /** Validate items before adding */\n  validateBeforeAdd?: boolean;\n}\n\n/**\n * Bulk cart hook result\n */\nexport interface UseBulkCartResult {\n  /** Add multiple items at once */\n  addBulkItems: (items: BulkItemInput[]) => Promise<CSVImportResult>;\n  /** Import from CSV string */\n  importFromCSV: (csvContent: string) => Promise<CSVImportResult>;\n  /** Clear and replace cart contents */\n  replaceCart: (items: BulkItemInput[]) => Promise<ExtendedCart>;\n  /** Duplicate items (e.g., from previous order) */\n  duplicateFromOrder: (orderId: string) => Promise<ExtendedCart>;\n  /** Loading state */\n  isProcessing: boolean;\n  /** Progress for bulk operations */\n  progress: { current: number; total: number };\n  /** Last error */\n  error: Error | null;\n}\n\n/**\n * Parse CSV content into bulk items\n */\nfunction parseCSV(content: string): BulkItemInput[] {\n  const lines = content.trim().split(\"\\n\");\n  if (lines.length < 2) return [];\n\n  const header = lines[0].toLowerCase().split(\",\").map((h) => h.trim());\n  const skuIndex = header.findIndex((h) => h === \"sku\" || h === \"reference\");\n  const productIdIndex = header.findIndex((h) => h === \"productid\" || h === \"product_id\" || h === \"id\");\n  const variantIdIndex = header.findIndex((h) => h === \"variantid\" || h === \"variant_id\" || h === \"variant\");\n  const quantityIndex = header.findIndex((h) => h === \"quantity\" || h === \"qty\" || h === \"quantite\");\n\n  if (quantityIndex === -1) {\n    throw new Error(\"CSV must contain a quantity column\");\n  }\n  if (skuIndex === -1 && productIdIndex === -1) {\n    throw new Error(\"CSV must contain a sku or productId column\");\n  }\n\n  const items: BulkItemInput[] = [];\n  for (let i = 1; i < lines.length; i++) {\n    const values = lines[i].split(\",\").map((v) => v.trim());\n    const quantity = parseInt(values[quantityIndex], 10);\n\n    if (isNaN(quantity) || quantity <= 0) continue;\n\n    items.push({\n      productId: productIdIndex >= 0 ? values[productIdIndex] : \"\",\n      sku: skuIndex >= 0 ? values[skuIndex] : undefined,\n      variantId: variantIdIndex >= 0 ? values[variantIdIndex] : undefined,\n      quantity,\n    });\n  }\n\n  return items;\n}\n\n/**\n * Hook for bulk cart operations in B2B context\n *\n * @param api - API client instance\n * @param options - Hook options\n * @returns Bulk cart actions and state\n *\n * @example\n * ```typescript\n * const {\n *   addBulkItems,\n *   importFromCSV,\n *   duplicateFromOrder,\n *   isProcessing,\n *   progress\n * } = useBulkCart(api, { cartId: 'cart_123' });\n *\n * // Add multiple items\n * const result = await addBulkItems([\n *   { productId: 'prod_1', quantity: 10 },\n *   { productId: 'prod_2', quantity: 5 },\n * ]);\n *\n * // Import from CSV\n * const csvResult = await importFromCSV(csvFileContent);\n * ```\n */\nexport function useBulkCart(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  api: any, // ICommerceClient\n  options: UseBulkCartOptions\n): UseBulkCartResult {\n  const { cartId, batchSize = 10, validateBeforeAdd = true } = options;\n\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [progress, setProgress] = useState({ current: 0, total: 0 });\n  const [error, setError] = useState<Error | null>(null);\n\n  const addBulkItems = useCallback(\n    async (items: BulkItemInput[]): Promise<CSVImportResult> => {\n      if (!api?.cart) {\n        throw new Error(\"Cart API not available\");\n      }\n\n      setIsProcessing(true);\n      setError(null);\n      setProgress({ current: 0, total: items.length });\n\n      const result: CSVImportResult = {\n        added: [],\n        failed: [],\n        skipped: [],\n      };\n\n      // Process in batches\n      for (let i = 0; i < items.length; i += batchSize) {\n        const batch = items.slice(i, i + batchSize);\n\n        await Promise.all(\n          batch.map(async (item) => {\n            try {\n              // Resolve SKU to product ID if needed\n              let productId = item.productId;\n              if (!productId && item.sku && api.products?.findBySku) {\n                const product = await api.products.findBySku(item.sku);\n                if (product) {\n                  productId = product.id;\n                }\n              }\n\n              if (!productId) {\n                result.failed.push({\n                  item,\n                  reason: \"Product not found\",\n                });\n                return;\n              }\n\n              // Validate stock if enabled\n              if (validateBeforeAdd && api.products?.getInventory) {\n                const inventory = await api.products.getInventory(productId);\n                if (inventory.available < item.quantity) {\n                  result.failed.push({\n                    item,\n                    reason: `Insufficient stock: ${inventory.available} available`,\n                  });\n                  return;\n                }\n              }\n\n              // Add to cart\n              await api.cart.addItem(cartId, {\n                productId,\n                variantId: item.variantId,\n                quantity: item.quantity,\n              });\n\n              result.added.push(item);\n            } catch (err) {\n              result.failed.push({\n                item,\n                reason: err instanceof Error ? err.message : \"Unknown error\",\n              });\n            }\n          })\n        );\n\n        setProgress({ current: Math.min(i + batchSize, items.length), total: items.length });\n      }\n\n      invalidateQueries([\"cart\", cartId]);\n      setIsProcessing(false);\n\n      return result;\n    },\n    [api, cartId, batchSize, validateBeforeAdd]\n  );\n\n  const importFromCSV = useCallback(\n    async (csvContent: string): Promise<CSVImportResult> => {\n      try {\n        const items = parseCSV(csvContent);\n        if (items.length === 0) {\n          throw new Error(\"No valid items found in CSV\");\n        }\n        return addBulkItems(items);\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error(String(err)));\n        throw err;\n      }\n    },\n    [addBulkItems]\n  );\n\n  const replaceCart = useCallback(\n    async (items: BulkItemInput[]): Promise<ExtendedCart> => {\n      if (!api?.cart) {\n        throw new Error(\"Cart API not available\");\n      }\n\n      setIsProcessing(true);\n      setError(null);\n\n      try {\n        // Get current cart and clear it\n        const currentCart = await api.cart.get(cartId);\n        for (let i = 0; i < currentCart.items.length; i++) {\n          const item = currentCart.items[i] as CartItemWithId;\n          const itemId = item.id ?? item.productId ?? item.product?.id ?? `item-${i}`;\n          await api.cart.removeItem(cartId, itemId);\n        }\n\n        // Add new items\n        await addBulkItems(items);\n\n        // Return updated cart\n        const updatedCart = await api.cart.get(cartId);\n        setIsProcessing(false);\n        return updatedCart;\n      } catch (err) {\n        setIsProcessing(false);\n        setError(err instanceof Error ? err : new Error(String(err)));\n        throw err;\n      }\n    },\n    [api, cartId, addBulkItems]\n  );\n\n  const duplicateFromOrder = useCallback(\n    async (orderId: string): Promise<ExtendedCart> => {\n      if (!api?.cart || !api?.orders) {\n        throw new Error(\"Cart or Orders API not available\");\n      }\n\n      setIsProcessing(true);\n      setError(null);\n\n      try {\n        // Get order items\n        const order = await api.orders.get(orderId);\n\n        // Convert to bulk items\n        const items: BulkItemInput[] = order.items.map((item: CartItemWithId) => ({\n          productId: item.productId ?? item.product?.id ?? \"\",\n          variantId: item.variantId,\n          quantity: item.quantity,\n        }));\n\n        // Add to cart\n        await addBulkItems(items);\n\n        // Return updated cart\n        const updatedCart = await api.cart.get(cartId);\n        setIsProcessing(false);\n        return updatedCart;\n      } catch (err) {\n        setIsProcessing(false);\n        setError(err instanceof Error ? err : new Error(String(err)));\n        throw err;\n      }\n    },\n    [api, cartId, addBulkItems]\n  );\n\n  return {\n    addBulkItems,\n    importFromCSV,\n    replaceCart,\n    duplicateFromOrder,\n    isProcessing,\n    progress,\n    error,\n  };\n}\n"],"mappings":"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","names":["import_react","import_react","import_react"]}