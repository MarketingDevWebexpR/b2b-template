{"version":3,"sources":["../src/cache.ts","../src/retry.ts","../src/interceptors.ts"],"names":["ApiError","NetworkError","TimeoutError","RateLimitError"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Cache system for API requests\n *\n * Provides in-memory caching with TTL (time-to-live) and stale time support.\n * Supports pattern-based invalidation and external cache adapters for distributed caching.\n *\n * @example\n * ```typescript\n * // Create a cache with 5-minute TTL and 1-minute stale time\n * const cache = new ApiCache({ ttl: 300_000, staleTime: 60_000 });\n *\n * // Store a value\n * cache.set('users:123', userData);\n *\n * // Retrieve with freshness info\n * const entry = cache.get('users:123');\n * if (entry) {\n *   console.log(entry.data, entry.isStale);\n * }\n *\n * // Invalidate by pattern\n * cache.invalidateByPattern(/^users:/);\n * ```\n */\n\n/**\n * Configuration options for the cache\n */\nexport interface CacheConfig {\n  /** Time-to-live in milliseconds (how long until entry expires completely) */\n  readonly ttl: number;\n  /** Stale time in milliseconds (how long until entry is considered stale but still usable) */\n  readonly staleTime?: number;\n  /** Maximum number of entries in the cache (uses LRU eviction when exceeded) */\n  readonly maxEntries?: number;\n  /** Optional external cache adapter for distributed caching */\n  readonly adapter?: CacheAdapter;\n}\n\n/**\n * Internal cache entry structure\n */\ninterface CacheEntry<T> {\n  /** The cached data */\n  readonly data: T;\n  /** Timestamp when the entry was created */\n  readonly createdAt: number;\n  /** Timestamp when the entry becomes stale */\n  readonly staleAt: number;\n  /** Timestamp when the entry expires */\n  readonly expiresAt: number;\n}\n\n/**\n * Result of a cache lookup including freshness information\n */\nexport interface CacheResult<T> {\n  /** The cached data */\n  readonly data: T;\n  /** Whether the entry is stale (past staleTime but not yet expired) */\n  readonly isStale: boolean;\n  /** Timestamp when the entry was created */\n  readonly createdAt: number;\n  /** Time remaining until expiration in milliseconds */\n  readonly timeToExpire: number;\n}\n\n/**\n * Interface for external cache adapters (Redis, Memcached, etc.)\n *\n * @example\n * ```typescript\n * // Example Redis adapter implementation\n * const redisAdapter: CacheAdapter = {\n *   async get(key) {\n *     const data = await redis.get(key);\n *     return data ? JSON.parse(data) : null;\n *   },\n *   async set(key, value, ttl) {\n *     await redis.setex(key, Math.ceil(ttl / 1000), JSON.stringify(value));\n *   },\n *   async delete(key) {\n *     await redis.del(key);\n *   },\n *   async has(key) {\n *     return (await redis.exists(key)) === 1;\n *   },\n *   async clear() {\n *     await redis.flushdb();\n *   },\n *   async keys(pattern) {\n *     // Convert regex-like pattern to Redis glob pattern\n *     return redis.keys(pattern);\n *   }\n * };\n * ```\n */\nexport interface CacheAdapter {\n  /**\n   * Retrieve an entry from the cache\n   * @param key - The cache key\n   * @returns The cached entry or null if not found\n   */\n  get<T>(key: string): Promise<CacheEntry<T> | null>;\n\n  /**\n   * Store an entry in the cache\n   * @param key - The cache key\n   * @param entry - The entry to store\n   * @param ttl - Time-to-live in milliseconds\n   */\n  set<T>(key: string, entry: CacheEntry<T>, ttl: number): Promise<void>;\n\n  /**\n   * Delete an entry from the cache\n   * @param key - The cache key\n   */\n  delete(key: string): Promise<boolean>;\n\n  /**\n   * Check if a key exists in the cache\n   * @param key - The cache key\n   */\n  has(key: string): Promise<boolean>;\n\n  /**\n   * Clear all entries from the cache\n   */\n  clear(): Promise<void>;\n\n  /**\n   * Get all keys matching a pattern (for pattern-based invalidation)\n   * @param pattern - A string pattern (adapter-specific format, e.g., \"users:*\" for Redis)\n   */\n  keys(pattern: string): Promise<string[]>;\n}\n\n/**\n * Parameters used to generate a cache key\n */\nexport interface CacheKeyParams {\n  /** HTTP method */\n  readonly method?: string;\n  /** Request path/URL */\n  readonly path: string;\n  /** Query parameters */\n  readonly params?: Readonly<Record<string, unknown>>;\n  /** Request body (for POST/PUT/PATCH) */\n  readonly body?: unknown;\n  /** Additional key components */\n  readonly extra?: readonly string[];\n}\n\n/**\n * Generate a deterministic cache key from request parameters\n *\n * @param params - The parameters to generate a key from\n * @returns A deterministic string key\n *\n * @example\n * ```typescript\n * const key = generateCacheKey({\n *   method: 'GET',\n *   path: '/api/users',\n *   params: { page: 1, limit: 10 }\n * });\n * // Returns: \"GET:/api/users:{\"limit\":10,\"page\":1}\"\n * ```\n */\nexport function generateCacheKey(params: CacheKeyParams): string {\n  const parts: string[] = [];\n\n  if (params.method) {\n    parts.push(params.method.toUpperCase());\n  }\n\n  parts.push(params.path);\n\n  if (params.params && Object.keys(params.params).length > 0) {\n    // Sort keys for deterministic output\n    const sortedParams: Record<string, unknown> = {};\n    for (const key of Object.keys(params.params).sort()) {\n      sortedParams[key] = params.params[key];\n    }\n    parts.push(JSON.stringify(sortedParams));\n  }\n\n  if (params.body !== undefined) {\n    parts.push(JSON.stringify(params.body));\n  }\n\n  if (params.extra && params.extra.length > 0) {\n    parts.push(...params.extra);\n  }\n\n  return parts.join(\":\");\n}\n\n/**\n * In-memory cache implementation with TTL and stale time support\n *\n * The cache implements a stale-while-revalidate pattern:\n * - Fresh: Entry is within staleTime, can be used immediately\n * - Stale: Entry is past staleTime but before TTL, can be used but should be refreshed\n * - Expired: Entry is past TTL, should not be used\n *\n * @example\n * ```typescript\n * const cache = new ApiCache({\n *   ttl: 5 * 60 * 1000,      // 5 minutes until expiry\n *   staleTime: 60 * 1000,    // 1 minute until stale\n *   maxEntries: 1000         // LRU eviction after 1000 entries\n * });\n *\n * // Cache a user response\n * cache.set('user:123', { id: 123, name: 'John' });\n *\n * // Later, check the cache\n * const result = cache.get('user:123');\n * if (result) {\n *   if (result.isStale) {\n *     // Use cached data but refresh in background\n *     refreshUser(123);\n *   }\n *   return result.data;\n * }\n * ```\n */\nexport class ApiCache {\n  private readonly cache: Map<string, CacheEntry<unknown>>;\n  private readonly config: Required<Omit<CacheConfig, \"adapter\">> & {\n    adapter?: CacheAdapter;\n  };\n  private readonly accessOrder: Map<string, number>;\n  private accessCounter: number;\n\n  constructor(config: CacheConfig) {\n    this.cache = new Map();\n    this.accessOrder = new Map();\n    this.accessCounter = 0;\n    this.config = {\n      ttl: config.ttl,\n      staleTime: config.staleTime ?? config.ttl,\n      maxEntries: config.maxEntries ?? 1000,\n      adapter: config.adapter,\n    };\n  }\n\n  /**\n   * Store a value in the cache\n   *\n   * @param key - The cache key\n   * @param data - The data to cache\n   * @param options - Optional override for TTL and stale time\n   *\n   * @example\n   * ```typescript\n   * // Use default TTL\n   * cache.set('products:list', products);\n   *\n   * // Override TTL for this entry\n   * cache.set('session:abc', sessionData, { ttl: 30 * 60 * 1000 });\n   * ```\n   */\n  async set<T>(\n    key: string,\n    data: T,\n    options?: { readonly ttl?: number; readonly staleTime?: number }\n  ): Promise<void> {\n    const now = Date.now();\n    const ttl = options?.ttl ?? this.config.ttl;\n    const staleTime = options?.staleTime ?? this.config.staleTime;\n\n    const entry: CacheEntry<T> = {\n      data,\n      createdAt: now,\n      staleAt: now + staleTime,\n      expiresAt: now + ttl,\n    };\n\n    // Enforce maxEntries with LRU eviction\n    if (this.cache.size >= this.config.maxEntries && !this.cache.has(key)) {\n      this.evictLRU();\n    }\n\n    this.cache.set(key, entry);\n    this.updateAccessOrder(key);\n\n    // Also store in external adapter if configured\n    if (this.config.adapter) {\n      await this.config.adapter.set(key, entry, ttl);\n    }\n  }\n\n  /**\n   * Retrieve a value from the cache\n   *\n   * @param key - The cache key\n   * @returns The cache result with data and freshness info, or null if not found/expired\n   *\n   * @example\n   * ```typescript\n   * const result = cache.get('users:123');\n   * if (result) {\n   *   console.log('Data:', result.data);\n   *   console.log('Is stale:', result.isStale);\n   *   console.log('Expires in:', result.timeToExpire, 'ms');\n   * }\n   * ```\n   */\n  async get<T>(key: string): Promise<CacheResult<T> | null> {\n    const now = Date.now();\n\n    // Try local cache first\n    let entry = this.cache.get(key) as CacheEntry<T> | undefined;\n\n    // If not in local cache, try external adapter\n    if (!entry && this.config.adapter) {\n      entry = (await this.config.adapter.get<T>(key)) ?? undefined;\n      // Store in local cache for faster subsequent access\n      if (entry) {\n        this.cache.set(key, entry);\n      }\n    }\n\n    if (!entry) {\n      return null;\n    }\n\n    // Check if expired\n    if (now >= entry.expiresAt) {\n      // Clean up expired entry\n      this.cache.delete(key);\n      if (this.config.adapter) {\n        await this.config.adapter.delete(key);\n      }\n      return null;\n    }\n\n    this.updateAccessOrder(key);\n\n    return {\n      data: entry.data,\n      isStale: now >= entry.staleAt,\n      createdAt: entry.createdAt,\n      timeToExpire: entry.expiresAt - now,\n    };\n  }\n\n  /**\n   * Check if a key exists in the cache and is not expired\n   *\n   * @param key - The cache key\n   * @returns true if the key exists and is not expired\n   *\n   * @example\n   * ```typescript\n   * if (await cache.has('user:123')) {\n   *   // Use cached data\n   * }\n   * ```\n   */\n  async has(key: string): Promise<boolean> {\n    const result = await this.get(key);\n    return result !== null;\n  }\n\n  /**\n   * Delete a specific key from the cache\n   *\n   * @param key - The cache key to delete\n   * @returns true if the key was found and deleted\n   *\n   * @example\n   * ```typescript\n   * // Invalidate a specific user's cache\n   * await cache.delete('user:123');\n   * ```\n   */\n  async delete(key: string): Promise<boolean> {\n    const existed = this.cache.delete(key);\n    this.accessOrder.delete(key);\n\n    if (this.config.adapter) {\n      await this.config.adapter.delete(key);\n    }\n\n    return existed;\n  }\n\n  /**\n   * Invalidate all cache entries matching a pattern\n   *\n   * @param pattern - A RegExp to match against cache keys\n   * @returns The number of entries invalidated\n   *\n   * @example\n   * ```typescript\n   * // Invalidate all user-related cache entries\n   * const count = await cache.invalidateByPattern(/^user:/);\n   * console.log(`Invalidated ${count} entries`);\n   *\n   * // Invalidate all GET requests for products\n   * await cache.invalidateByPattern(/^GET:\\/api\\/products/);\n   * ```\n   */\n  async invalidateByPattern(pattern: RegExp): Promise<number> {\n    let count = 0;\n\n    // Invalidate from local cache\n    for (const key of this.cache.keys()) {\n      if (pattern.test(key)) {\n        this.cache.delete(key);\n        this.accessOrder.delete(key);\n        count++;\n      }\n    }\n\n    // Invalidate from external adapter if configured\n    if (this.config.adapter) {\n      // Convert RegExp to a simpler pattern for adapter\n      // Most adapters use glob-like patterns, so we do a best-effort conversion\n      const adapterPattern = pattern.source\n        .replace(/\\^/g, \"\")\n        .replace(/\\$/g, \"\")\n        .replace(/\\.\\*/g, \"*\")\n        .replace(/\\./g, \"?\");\n\n      const keys = await this.config.adapter.keys(adapterPattern);\n      for (const key of keys) {\n        if (pattern.test(key)) {\n          await this.config.adapter.delete(key);\n          count++;\n        }\n      }\n    }\n\n    return count;\n  }\n\n  /**\n   * Invalidate cache entries by prefix\n   *\n   * @param prefix - The prefix to match\n   * @returns The number of entries invalidated\n   *\n   * @example\n   * ```typescript\n   * // Invalidate all entries starting with \"products:\"\n   * const count = await cache.invalidateByPrefix('products:');\n   * ```\n   */\n  async invalidateByPrefix(prefix: string): Promise<number> {\n    return this.invalidateByPattern(\n      new RegExp(`^${prefix.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\")}`)\n    );\n  }\n\n  /**\n   * Clear all entries from the cache\n   *\n   * @example\n   * ```typescript\n   * // Clear entire cache\n   * await cache.clear();\n   * ```\n   */\n  async clear(): Promise<void> {\n    this.cache.clear();\n    this.accessOrder.clear();\n    this.accessCounter = 0;\n\n    if (this.config.adapter) {\n      await this.config.adapter.clear();\n    }\n  }\n\n  /**\n   * Get the current number of entries in the local cache\n   *\n   * @returns The number of cached entries\n   */\n  get size(): number {\n    return this.cache.size;\n  }\n\n  /**\n   * Get all keys currently in the local cache\n   *\n   * @returns An array of cache keys\n   */\n  keys(): string[] {\n    return Array.from(this.cache.keys());\n  }\n\n  /**\n   * Get cache statistics\n   *\n   * @returns Object with cache statistics\n   *\n   * @example\n   * ```typescript\n   * const stats = cache.stats();\n   * console.log(`Cache has ${stats.size} entries`);\n   * console.log(`${stats.staleCount} entries are stale`);\n   * ```\n   */\n  stats(): {\n    size: number;\n    staleCount: number;\n    freshCount: number;\n    maxEntries: number;\n  } {\n    const now = Date.now();\n    let staleCount = 0;\n    let freshCount = 0;\n\n    for (const entry of this.cache.values()) {\n      if (now >= entry.expiresAt) {\n        continue; // Expired entries don't count\n      }\n      if (now >= entry.staleAt) {\n        staleCount++;\n      } else {\n        freshCount++;\n      }\n    }\n\n    return {\n      size: this.cache.size,\n      staleCount,\n      freshCount,\n      maxEntries: this.config.maxEntries,\n    };\n  }\n\n  /**\n   * Update the access order for LRU tracking\n   */\n  private updateAccessOrder(key: string): void {\n    this.accessCounter++;\n    this.accessOrder.set(key, this.accessCounter);\n  }\n\n  /**\n   * Evict the least recently used entry\n   */\n  private evictLRU(): void {\n    let oldestKey: string | null = null;\n    let oldestAccess = Infinity;\n\n    for (const [key, access] of this.accessOrder.entries()) {\n      if (access < oldestAccess) {\n        oldestAccess = access;\n        oldestKey = key;\n      }\n    }\n\n    if (oldestKey) {\n      this.cache.delete(oldestKey);\n      this.accessOrder.delete(oldestKey);\n    }\n  }\n}\n\n/**\n * Create a cache key generator with a prefix\n *\n * @param prefix - The prefix to add to all generated keys\n * @returns A function that generates prefixed cache keys\n *\n * @example\n * ```typescript\n * const userCacheKey = createCacheKeyGenerator('users');\n * const key = userCacheKey({ path: '/123', method: 'GET' });\n * // Returns: \"users:GET:/123\"\n * ```\n */\nexport function createCacheKeyGenerator(\n  prefix: string\n): (params: CacheKeyParams) => string {\n  return (params: CacheKeyParams) => {\n    const baseKey = generateCacheKey(params);\n    return `${prefix}:${baseKey}`;\n  };\n}\n","/**\n * Retry logic with exponential backoff for API requests\n *\n * Provides configurable retry mechanisms with support for:\n * - Exponential backoff with jitter\n * - Configurable retry conditions\n * - AbortSignal support for cancellation\n * - Custom delay strategies\n *\n * @example\n * ```typescript\n * const retry = createRetryHandler({\n *   maxRetries: 3,\n *   initialDelay: 1000,\n *   maxDelay: 30000,\n *   backoffMultiplier: 2,\n *   retryOn: [408, 429, 500, 502, 503, 504]\n * });\n *\n * const result = await retry(async () => {\n *   return fetch('/api/data');\n * });\n * ```\n */\n\nimport { ApiError, NetworkError, RateLimitError, TimeoutError } from \"./errors\";\n\n/**\n * Configuration for retry behavior\n */\nexport interface RetryConfig {\n  /** Maximum number of retry attempts (default: 3) */\n  readonly maxRetries?: number;\n  /** Initial delay in milliseconds before first retry (default: 1000) */\n  readonly initialDelay?: number;\n  /** Maximum delay in milliseconds between retries (default: 30000) */\n  readonly maxDelay?: number;\n  /** Multiplier for exponential backoff (default: 2) */\n  readonly backoffMultiplier?: number;\n  /** Whether to add random jitter to delays (default: true) */\n  readonly jitter?: boolean;\n  /** HTTP status codes that should trigger a retry */\n  readonly retryOnStatus?: readonly number[];\n  /** Error types that should trigger a retry */\n  readonly retryOnError?: readonly RetryableErrorType[];\n  /** Custom function to determine if a retry should occur */\n  readonly shouldRetry?: RetryPredicate;\n  /** AbortSignal to cancel retries */\n  readonly signal?: AbortSignal;\n  /** Callback invoked before each retry attempt */\n  readonly onRetry?: RetryCallback;\n}\n\n/**\n * Error types that can be configured for retry\n */\nexport type RetryableErrorType =\n  | \"NetworkError\"\n  | \"TimeoutError\"\n  | \"RateLimitError\"\n  | \"ApiError\";\n\n/**\n * Predicate function to determine if a retry should occur\n *\n * @param error - The error that occurred\n * @param attempt - The current attempt number (1-indexed)\n * @returns true if the request should be retried\n */\nexport type RetryPredicate = (error: unknown, attempt: number) => boolean;\n\n/**\n * Callback invoked before each retry attempt\n *\n * @param error - The error that triggered the retry\n * @param attempt - The current attempt number (1-indexed)\n * @param delay - The delay in milliseconds before the next attempt\n */\nexport type RetryCallback = (\n  error: unknown,\n  attempt: number,\n  delay: number\n) => void;\n\n/**\n * Context provided during retry execution\n */\nexport interface RetryContext {\n  /** Current attempt number (1-indexed) */\n  readonly attempt: number;\n  /** Total number of retries allowed */\n  readonly maxRetries: number;\n  /** Delay before the next retry (if applicable) */\n  readonly nextDelay: number;\n  /** Whether this is the last attempt */\n  readonly isLastAttempt: boolean;\n}\n\n/**\n * Result of a retry operation\n */\nexport interface RetryResult<T> {\n  /** The successful result data */\n  readonly data: T;\n  /** Number of attempts made (1 = success on first try) */\n  readonly attempts: number;\n  /** Total time spent including retries in milliseconds */\n  readonly totalTime: number;\n}\n\n/**\n * Error thrown when all retry attempts are exhausted\n */\nexport class RetryExhaustedError extends ApiError {\n  public override readonly name = \"RetryExhaustedError\";\n  public readonly attempts: number;\n  public readonly lastError: unknown;\n\n  constructor(attempts: number, lastError: unknown) {\n    const message =\n      lastError instanceof Error\n        ? `All ${attempts} retry attempts failed. Last error: ${lastError.message}`\n        : `All ${attempts} retry attempts failed`;\n\n    super(message, {\n      code: \"RETRY_EXHAUSTED\",\n      details: { attempts },\n      cause: lastError instanceof Error ? lastError : undefined,\n    });\n\n    this.attempts = attempts;\n    this.lastError = lastError;\n  }\n}\n\n/**\n * Default retry configuration\n */\nconst DEFAULT_CONFIG: Required<\n  Omit<RetryConfig, \"shouldRetry\" | \"signal\" | \"onRetry\">\n> = {\n  maxRetries: 3,\n  initialDelay: 1000,\n  maxDelay: 30_000,\n  backoffMultiplier: 2,\n  jitter: true,\n  retryOnStatus: [408, 429, 500, 502, 503, 504],\n  retryOnError: [\"NetworkError\", \"TimeoutError\", \"RateLimitError\"],\n};\n\n/**\n * Calculate the delay for a retry attempt using exponential backoff\n *\n * @param attempt - The current attempt number (1-indexed)\n * @param config - The retry configuration\n * @returns The delay in milliseconds\n *\n * @example\n * ```typescript\n * // With default config (initialDelay: 1000, multiplier: 2)\n * calculateDelay(1, config); // ~1000ms\n * calculateDelay(2, config); // ~2000ms\n * calculateDelay(3, config); // ~4000ms\n * ```\n */\nexport function calculateDelay(\n  attempt: number,\n  config: Pick<\n    RetryConfig,\n    \"initialDelay\" | \"maxDelay\" | \"backoffMultiplier\" | \"jitter\"\n  >\n): number {\n  const initialDelay = config.initialDelay ?? DEFAULT_CONFIG.initialDelay;\n  const maxDelay = config.maxDelay ?? DEFAULT_CONFIG.maxDelay;\n  const multiplier = config.backoffMultiplier ?? DEFAULT_CONFIG.backoffMultiplier;\n  const useJitter = config.jitter ?? DEFAULT_CONFIG.jitter;\n\n  // Calculate exponential delay: initialDelay * multiplier^(attempt-1)\n  const exponentialDelay = initialDelay * Math.pow(multiplier, attempt - 1);\n\n  // Cap at maxDelay\n  let delay = Math.min(exponentialDelay, maxDelay);\n\n  // Add jitter (random factor between 0.5 and 1.5)\n  if (useJitter) {\n    const jitterFactor = 0.5 + Math.random();\n    delay = Math.floor(delay * jitterFactor);\n  }\n\n  return delay;\n}\n\n/**\n * Check if an error matches the configured retry conditions\n *\n * @param error - The error to check\n * @param config - The retry configuration\n * @returns true if the error should trigger a retry\n */\nfunction shouldRetryError(\n  error: unknown,\n  config: Pick<RetryConfig, \"retryOnStatus\" | \"retryOnError\">\n): boolean {\n  const retryOnStatus = config.retryOnStatus ?? DEFAULT_CONFIG.retryOnStatus;\n  const retryOnError = config.retryOnError ?? DEFAULT_CONFIG.retryOnError;\n\n  // Check for ApiError with status code\n  if (error instanceof ApiError) {\n    // Check status code\n    if (retryOnStatus.includes(error.statusCode)) {\n      return true;\n    }\n\n    // Check error type\n    if (retryOnError.includes(error.name as RetryableErrorType)) {\n      return true;\n    }\n  }\n\n  // Check specific error types\n  if (error instanceof NetworkError && retryOnError.includes(\"NetworkError\")) {\n    return true;\n  }\n\n  if (error instanceof TimeoutError && retryOnError.includes(\"TimeoutError\")) {\n    return true;\n  }\n\n  if (\n    error instanceof RateLimitError &&\n    retryOnError.includes(\"RateLimitError\")\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Get the retry delay, considering RateLimitError's retryAfter header\n *\n * @param error - The error that occurred\n * @param calculatedDelay - The delay calculated from exponential backoff\n * @returns The delay to use in milliseconds\n */\nfunction getRetryDelay(error: unknown, calculatedDelay: number): number {\n  // RateLimitError may include a retryAfter value from the server\n  if (error instanceof RateLimitError && error.retryAfter !== undefined) {\n    // retryAfter is in seconds, convert to milliseconds\n    const serverDelay = error.retryAfter * 1000;\n    // Use the longer of the two delays\n    return Math.max(serverDelay, calculatedDelay);\n  }\n\n  return calculatedDelay;\n}\n\n/**\n * Sleep for a specified duration with abort support\n *\n * @param ms - Duration in milliseconds\n * @param signal - Optional AbortSignal to cancel the sleep\n */\nasync function sleep(ms: number, signal?: AbortSignal): Promise<void> {\n  return new Promise((resolve, reject) => {\n    if (signal?.aborted) {\n      reject(new DOMException(\"Aborted\", \"AbortError\"));\n      return;\n    }\n\n    const timeoutId = setTimeout(resolve, ms);\n\n    signal?.addEventListener(\n      \"abort\",\n      () => {\n        clearTimeout(timeoutId);\n        reject(new DOMException(\"Aborted\", \"AbortError\"));\n      },\n      { once: true }\n    );\n  });\n}\n\n/**\n * Retry handler function type\n */\nexport type RetryHandler = <T>(\n  operation: () => Promise<T>,\n  config?: RetryConfig\n) => Promise<RetryResult<T>>;\n\n/**\n * Create a retry handler with pre-configured defaults\n *\n * @param defaultConfig - Default configuration for all retries\n * @returns A retry handler function\n *\n * @example\n * ```typescript\n * // Create a retry handler with custom defaults\n * const retry = createRetryHandler({\n *   maxRetries: 5,\n *   initialDelay: 500,\n *   retryOnStatus: [429, 500, 502, 503, 504]\n * });\n *\n * // Use the handler\n * const result = await retry(async () => {\n *   const response = await fetch('/api/data');\n *   if (!response.ok) throw new Error('Request failed');\n *   return response.json();\n * });\n *\n * console.log(`Succeeded after ${result.attempts} attempts`);\n * ```\n */\nexport function createRetryHandler(defaultConfig: RetryConfig = {}): RetryHandler {\n  return async function retry<T>(\n    operation: () => Promise<T>,\n    overrideConfig: RetryConfig = {}\n  ): Promise<RetryResult<T>> {\n    // Merge configs: override > default > DEFAULT_CONFIG\n    const config: Required<\n      Omit<RetryConfig, \"shouldRetry\" | \"signal\" | \"onRetry\">\n    > & Pick<RetryConfig, \"shouldRetry\" | \"signal\" | \"onRetry\"> = {\n      ...DEFAULT_CONFIG,\n      ...defaultConfig,\n      ...overrideConfig,\n    };\n\n    const maxAttempts = config.maxRetries + 1; // +1 for initial attempt\n    const startTime = Date.now();\n    let lastError: unknown;\n\n    for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n      // Check if aborted before attempting\n      if (config.signal?.aborted) {\n        throw new DOMException(\"Aborted\", \"AbortError\");\n      }\n\n      try {\n        const data = await operation();\n        return {\n          data,\n          attempts: attempt,\n          totalTime: Date.now() - startTime,\n        };\n      } catch (error) {\n        lastError = error;\n\n        // Don't retry on abort\n        if (\n          error instanceof DOMException &&\n          error.name === \"AbortError\"\n        ) {\n          throw error;\n        }\n\n        // Check if we should retry\n        const isLastAttempt = attempt >= maxAttempts;\n        if (isLastAttempt) {\n          break;\n        }\n\n        // Check custom predicate first\n        if (config.shouldRetry) {\n          if (!config.shouldRetry(error, attempt)) {\n            break;\n          }\n        } else if (!shouldRetryError(error, config)) {\n          // Fall back to built-in check\n          break;\n        }\n\n        // Calculate delay\n        const baseDelay = calculateDelay(attempt, config);\n        const delay = getRetryDelay(error, baseDelay);\n\n        // Call onRetry callback\n        if (config.onRetry) {\n          config.onRetry(error, attempt, delay);\n        }\n\n        // Wait before retrying\n        await sleep(delay, config.signal);\n      }\n    }\n\n    // All retries exhausted\n    throw new RetryExhaustedError(maxAttempts, lastError);\n  };\n}\n\n/**\n * Execute an operation with retry logic\n *\n * This is a convenience function that creates a one-time retry handler.\n * For repeated use, prefer {@link createRetryHandler}.\n *\n * @param operation - The async operation to execute\n * @param config - Retry configuration\n * @returns The result of the operation with retry metadata\n *\n * @example\n * ```typescript\n * const result = await withRetry(\n *   async () => {\n *     const response = await fetch('/api/flaky-endpoint');\n *     if (!response.ok) {\n *       throw new ApiError('Request failed', { statusCode: response.status });\n *     }\n *     return response.json();\n *   },\n *   {\n *     maxRetries: 3,\n *     onRetry: (error, attempt, delay) => {\n *       console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);\n *     }\n *   }\n * );\n * ```\n */\nexport async function withRetry<T>(\n  operation: () => Promise<T>,\n  config: RetryConfig = {}\n): Promise<RetryResult<T>> {\n  const handler = createRetryHandler(config);\n  return handler(operation);\n}\n\n/**\n * Create a predicate that retries only on specific status codes\n *\n * @param statusCodes - The status codes to retry on\n * @returns A retry predicate function\n *\n * @example\n * ```typescript\n * const retry = createRetryHandler({\n *   shouldRetry: retryOnStatusCodes([429, 503])\n * });\n * ```\n */\nexport function retryOnStatusCodes(\n  statusCodes: readonly number[]\n): RetryPredicate {\n  return (error: unknown): boolean => {\n    if (error instanceof ApiError) {\n      return statusCodes.includes(error.statusCode);\n    }\n    return false;\n  };\n}\n\n/**\n * Create a predicate that retries only on specific error types\n *\n * @param errorTypes - The error types to retry on\n * @returns A retry predicate function\n *\n * @example\n * ```typescript\n * const retry = createRetryHandler({\n *   shouldRetry: retryOnErrorTypes(['NetworkError', 'TimeoutError'])\n * });\n * ```\n */\nexport function retryOnErrorTypes(\n  errorTypes: readonly RetryableErrorType[]\n): RetryPredicate {\n  return (error: unknown): boolean => {\n    if (error instanceof Error) {\n      return errorTypes.includes(error.name as RetryableErrorType);\n    }\n    return false;\n  };\n}\n\n/**\n * Combine multiple retry predicates with OR logic\n *\n * @param predicates - The predicates to combine\n * @returns A combined retry predicate\n *\n * @example\n * ```typescript\n * const retry = createRetryHandler({\n *   shouldRetry: combinePredicates(\n *     retryOnStatusCodes([429, 503]),\n *     retryOnErrorTypes(['NetworkError']),\n *     (error) => error instanceof CustomRetryableError\n *   )\n * });\n * ```\n */\nexport function combinePredicates(\n  ...predicates: readonly RetryPredicate[]\n): RetryPredicate {\n  return (error: unknown, attempt: number): boolean => {\n    return predicates.some((predicate) => predicate(error, attempt));\n  };\n}\n\n/**\n * Create a predicate with a maximum attempt limit\n *\n * @param predicate - The base predicate\n * @param maxAttempt - Maximum attempt number to allow retries\n * @returns A retry predicate that stops after maxAttempt\n *\n * @example\n * ```typescript\n * // Only retry network errors for the first 2 attempts\n * const retry = createRetryHandler({\n *   maxRetries: 5,\n *   shouldRetry: withMaxAttempts(\n *     retryOnErrorTypes(['NetworkError']),\n *     2\n *   )\n * });\n * ```\n */\nexport function withMaxAttempts(\n  predicate: RetryPredicate,\n  maxAttempt: number\n): RetryPredicate {\n  return (error: unknown, attempt: number): boolean => {\n    if (attempt >= maxAttempt) {\n      return false;\n    }\n    return predicate(error, attempt);\n  };\n}\n","/**\n * Interceptor system for API requests and responses\n *\n * Provides a middleware-like pattern for transforming requests before sending,\n * responses after receiving, and handling errors centrally.\n *\n * @example\n * ```typescript\n * const interceptors = new InterceptorManager();\n *\n * // Add auth header to all requests\n * interceptors.request.use(async (config) => ({\n *   ...config,\n *   headers: { ...config.headers, Authorization: `Bearer ${token}` }\n * }));\n *\n * // Log all responses\n * interceptors.response.use(async (response) => {\n *   console.log(`${response.status}: ${response.url}`);\n *   return response;\n * });\n *\n * // Handle errors globally\n * interceptors.error.use(async (error) => {\n *   if (error instanceof AuthenticationError) {\n *     await refreshToken();\n *     throw error; // Re-throw to trigger retry\n *   }\n *   throw error;\n * });\n * ```\n */\n\nimport type { ApiResponse, HttpMethod, RequestOptions } from \"./types\";\nimport { ApiError } from \"./errors\";\n\n/**\n * Configuration for an outgoing request (before fetch)\n */\nexport interface RequestConfig {\n  /** The request URL */\n  readonly url: string;\n  /** HTTP method */\n  readonly method: HttpMethod;\n  /** Request headers */\n  readonly headers: Record<string, string>;\n  /** Request body (for POST, PUT, PATCH) */\n  readonly body?: unknown;\n  /** Request timeout in milliseconds */\n  readonly timeout?: number;\n  /** Abort signal */\n  readonly signal?: AbortSignal;\n  /** Additional metadata that can be passed through the interceptor chain */\n  readonly metadata?: Readonly<Record<string, unknown>>;\n}\n\n/**\n * Mutable request configuration for interceptors to modify\n */\nexport interface MutableRequestConfig {\n  /** The request URL */\n  url: string;\n  /** HTTP method */\n  method: HttpMethod;\n  /** Request headers */\n  headers: Record<string, string>;\n  /** Request body (for POST, PUT, PATCH) */\n  body?: unknown;\n  /** Request timeout in milliseconds */\n  timeout?: number;\n  /** Abort signal */\n  signal?: AbortSignal;\n  /** Additional metadata that can be passed through the interceptor chain */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Response data passed through response interceptors\n */\nexport interface InterceptorResponse<T = unknown> {\n  /** Response data */\n  readonly data: T;\n  /** HTTP status code */\n  readonly status: number;\n  /** Response headers */\n  readonly headers: Headers;\n  /** Original request configuration */\n  readonly config: RequestConfig;\n  /** Additional metadata */\n  readonly metadata?: Readonly<Record<string, unknown>>;\n}\n\n/**\n * Mutable response for interceptors to modify\n */\nexport interface MutableInterceptorResponse<T = unknown> {\n  /** Response data */\n  data: T;\n  /** HTTP status code */\n  status: number;\n  /** Response headers */\n  headers: Headers;\n  /** Original request configuration */\n  config: RequestConfig;\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Error context passed through error interceptors\n */\nexport interface InterceptorError {\n  /** The error that occurred */\n  readonly error: unknown;\n  /** The request configuration that caused the error */\n  readonly config: RequestConfig;\n  /** The response if one was received (e.g., for HTTP errors) */\n  readonly response?: InterceptorResponse;\n}\n\n/**\n * Request interceptor function\n *\n * @param config - The request configuration\n * @returns Modified request configuration\n */\nexport type RequestInterceptor = (\n  config: MutableRequestConfig\n) => MutableRequestConfig | Promise<MutableRequestConfig>;\n\n/**\n * Response interceptor function\n *\n * @param response - The response data\n * @returns Modified response data\n */\nexport type ResponseInterceptor<T = unknown> = (\n  response: MutableInterceptorResponse<T>\n) => MutableInterceptorResponse<T> | Promise<MutableInterceptorResponse<T>>;\n\n/**\n * Error interceptor function\n *\n * @param context - The error context\n * @returns Should throw the error or a new error, or return a recovery response\n */\nexport type ErrorInterceptor<T = unknown> = (\n  context: InterceptorError\n) => Promise<MutableInterceptorResponse<T>> | never;\n\n/**\n * Handle for removing an interceptor\n */\nexport interface InterceptorHandle {\n  /** Remove this interceptor */\n  remove(): void;\n}\n\n/**\n * Internal interceptor entry with ID for removal\n */\ninterface InterceptorEntry<T> {\n  readonly id: number;\n  readonly interceptor: T;\n}\n\n/**\n * Chain of interceptors that can be added to and removed from\n *\n * @example\n * ```typescript\n * const chain = new InterceptorChain<RequestInterceptor>();\n *\n * // Add an interceptor\n * const handle = chain.use(async (config) => {\n *   config.headers['X-Custom'] = 'value';\n *   return config;\n * });\n *\n * // Later, remove it\n * handle.remove();\n * ```\n */\nexport class InterceptorChain<T extends (...args: never[]) => unknown> {\n  private readonly interceptors: InterceptorEntry<T>[] = [];\n  private nextId = 0;\n\n  /**\n   * Add an interceptor to the chain\n   *\n   * @param interceptor - The interceptor function\n   * @returns A handle to remove the interceptor\n   *\n   * @example\n   * ```typescript\n   * const handle = chain.use((config) => {\n   *   // Modify config\n   *   return config;\n   * });\n   *\n   * // Remove later\n   * handle.remove();\n   * ```\n   */\n  use(interceptor: T): InterceptorHandle {\n    const id = this.nextId++;\n    this.interceptors.push({ id, interceptor });\n\n    return {\n      remove: () => {\n        const index = this.interceptors.findIndex((entry) => entry.id === id);\n        if (index !== -1) {\n          this.interceptors.splice(index, 1);\n        }\n      },\n    };\n  }\n\n  /**\n   * Get all interceptors in order\n   *\n   * @returns Array of interceptor functions\n   */\n  getInterceptors(): readonly T[] {\n    return this.interceptors.map((entry) => entry.interceptor);\n  }\n\n  /**\n   * Check if any interceptors are registered\n   *\n   * @returns true if the chain has interceptors\n   */\n  hasInterceptors(): boolean {\n    return this.interceptors.length > 0;\n  }\n\n  /**\n   * Get the number of registered interceptors\n   */\n  get size(): number {\n    return this.interceptors.length;\n  }\n\n  /**\n   * Clear all interceptors from the chain\n   */\n  clear(): void {\n    this.interceptors.length = 0;\n  }\n}\n\n/**\n * Manager for all interceptor chains (request, response, error)\n *\n * @example\n * ```typescript\n * const manager = new InterceptorManager();\n *\n * // Add authentication\n * manager.request.use(async (config) => {\n *   const token = await getAuthToken();\n *   config.headers.Authorization = `Bearer ${token}`;\n *   return config;\n * });\n *\n * // Transform responses\n * manager.response.use(async (response) => {\n *   // Unwrap nested data structure\n *   if (response.data && typeof response.data === 'object' && 'result' in response.data) {\n *     response.data = response.data.result;\n *   }\n *   return response;\n * });\n *\n * // Handle errors\n * manager.error.use(async (context) => {\n *   logError(context.error);\n *   throw context.error;\n * });\n *\n * // Execute with interceptors\n * const config = await manager.runRequestInterceptors({\n *   url: '/api/users',\n *   method: 'GET',\n *   headers: {}\n * });\n * ```\n */\nexport class InterceptorManager {\n  /** Request interceptor chain */\n  public readonly request: InterceptorChain<RequestInterceptor>;\n  /** Response interceptor chain */\n  public readonly response: InterceptorChain<ResponseInterceptor>;\n  /** Error interceptor chain */\n  public readonly error: InterceptorChain<ErrorInterceptor>;\n\n  constructor() {\n    this.request = new InterceptorChain<RequestInterceptor>();\n    this.response = new InterceptorChain<ResponseInterceptor>();\n    this.error = new InterceptorChain<ErrorInterceptor>();\n  }\n\n  /**\n   * Run all request interceptors in order\n   *\n   * @param config - The initial request configuration\n   * @returns The modified request configuration\n   * @throws If any interceptor throws\n   *\n   * @example\n   * ```typescript\n   * const finalConfig = await manager.runRequestInterceptors({\n   *   url: 'https://api.example.com/users',\n   *   method: 'GET',\n   *   headers: { 'Content-Type': 'application/json' }\n   * });\n   * ```\n   */\n  async runRequestInterceptors(\n    config: RequestConfig\n  ): Promise<MutableRequestConfig> {\n    let mutableConfig: MutableRequestConfig = {\n      url: config.url,\n      method: config.method,\n      headers: { ...config.headers },\n      body: config.body,\n      timeout: config.timeout,\n      signal: config.signal,\n      metadata: config.metadata ? { ...config.metadata } : undefined,\n    };\n\n    for (const interceptor of this.request.getInterceptors()) {\n      mutableConfig = await interceptor(mutableConfig);\n    }\n\n    return mutableConfig;\n  }\n\n  /**\n   * Run all response interceptors in order\n   *\n   * @param response - The initial response data\n   * @returns The modified response data\n   * @throws If any interceptor throws\n   *\n   * @example\n   * ```typescript\n   * const finalResponse = await manager.runResponseInterceptors({\n   *   data: responseData,\n   *   status: 200,\n   *   headers: responseHeaders,\n   *   config: requestConfig\n   * });\n   * ```\n   */\n  async runResponseInterceptors<T>(\n    response: InterceptorResponse<T>\n  ): Promise<MutableInterceptorResponse<T>> {\n    let mutableResponse: MutableInterceptorResponse<T> = {\n      data: response.data,\n      status: response.status,\n      headers: response.headers,\n      config: response.config,\n      metadata: response.metadata ? { ...response.metadata } : undefined,\n    };\n\n    for (const interceptor of this.response.getInterceptors()) {\n      mutableResponse = await (interceptor as ResponseInterceptor<T>)(\n        mutableResponse\n      );\n    }\n\n    return mutableResponse;\n  }\n\n  /**\n   * Run all error interceptors in order\n   *\n   * Each interceptor can either:\n   * - Throw an error (possibly transformed)\n   * - Return a recovery response (to convert error to success)\n   *\n   * @param context - The error context\n   * @returns A recovery response if any interceptor returns one\n   * @throws The final error if no interceptor returns a recovery response\n   *\n   * @example\n   * ```typescript\n   * try {\n   *   const response = await manager.runErrorInterceptors({\n   *     error: new AuthenticationError('Token expired'),\n   *     config: requestConfig\n   *   });\n   *   // An interceptor returned a recovery response\n   *   return response;\n   * } catch (error) {\n   *   // All interceptors threw, final error is rethrown\n   *   throw error;\n   * }\n   * ```\n   */\n  async runErrorInterceptors<T>(\n    context: InterceptorError\n  ): Promise<MutableInterceptorResponse<T>> {\n    let currentContext = context;\n\n    for (const interceptor of this.error.getInterceptors()) {\n      try {\n        // If interceptor returns a response, use it as recovery\n        const response = await (interceptor as ErrorInterceptor<T>)(\n          currentContext\n        );\n        return response;\n      } catch (error) {\n        // Update context with new error for next interceptor\n        currentContext = {\n          ...currentContext,\n          error,\n        };\n      }\n    }\n\n    // No interceptor returned a recovery response, throw the final error\n    throw currentContext.error;\n  }\n\n  /**\n   * Clear all interceptors from all chains\n   */\n  clear(): void {\n    this.request.clear();\n    this.response.clear();\n    this.error.clear();\n  }\n}\n\n/**\n * Create common request interceptors\n */\nexport const commonInterceptors = {\n  /**\n   * Add a bearer token to all requests\n   *\n   * @param getToken - Function to get the current token\n   * @returns A request interceptor\n   *\n   * @example\n   * ```typescript\n   * manager.request.use(\n   *   commonInterceptors.bearerAuth(() => localStorage.getItem('token'))\n   * );\n   * ```\n   */\n  bearerAuth(\n    getToken: () => string | null | Promise<string | null>\n  ): RequestInterceptor {\n    return async (config) => {\n      const token = await getToken();\n      if (token) {\n        config.headers[\"Authorization\"] = `Bearer ${token}`;\n      }\n      return config;\n    };\n  },\n\n  /**\n   * Add custom headers to all requests\n   *\n   * @param headers - Headers to add\n   * @returns A request interceptor\n   *\n   * @example\n   * ```typescript\n   * manager.request.use(\n   *   commonInterceptors.headers({ 'X-API-Version': '2' })\n   * );\n   * ```\n   */\n  headers(\n    headers: Record<string, string> | (() => Record<string, string>)\n  ): RequestInterceptor {\n    return (config) => {\n      const headersToAdd =\n        typeof headers === \"function\" ? headers() : headers;\n      Object.assign(config.headers, headersToAdd);\n      return config;\n    };\n  },\n\n  /**\n   * Add request timing metadata\n   *\n   * @returns A request interceptor that adds a start timestamp\n   *\n   * @example\n   * ```typescript\n   * manager.request.use(commonInterceptors.timing());\n   * manager.response.use((response) => {\n   *   const startTime = response.config.metadata?.startTime as number;\n   *   console.log(`Request took ${Date.now() - startTime}ms`);\n   *   return response;\n   * });\n   * ```\n   */\n  timing(): RequestInterceptor {\n    return (config) => {\n      config.metadata = {\n        ...config.metadata,\n        startTime: Date.now(),\n      };\n      return config;\n    };\n  },\n\n  /**\n   * Log requests for debugging\n   *\n   * @param logger - Optional custom logger (defaults to console)\n   * @returns A request interceptor\n   *\n   * @example\n   * ```typescript\n   * manager.request.use(commonInterceptors.logRequest());\n   * ```\n   */\n  logRequest(\n    logger: Pick<Console, \"log\"> = console\n  ): RequestInterceptor {\n    return (config) => {\n      logger.log(`[API Request] ${config.method} ${config.url}`);\n      return config;\n    };\n  },\n\n  /**\n   * Log responses for debugging\n   *\n   * @param logger - Optional custom logger (defaults to console)\n   * @returns A response interceptor\n   *\n   * @example\n   * ```typescript\n   * manager.response.use(commonInterceptors.logResponse());\n   * ```\n   */\n  logResponse(\n    logger: Pick<Console, \"log\"> = console\n  ): ResponseInterceptor {\n    return (response) => {\n      const startTime = response.config.metadata?.[\"startTime\"];\n      const duration =\n        typeof startTime === \"number\" ? Date.now() - startTime : undefined;\n      const durationStr = duration !== undefined ? ` (${duration}ms)` : \"\";\n      logger.log(\n        `[API Response] ${response.status} ${response.config.method} ${response.config.url}${durationStr}`\n      );\n      return response;\n    };\n  },\n\n  /**\n   * Log errors for debugging\n   *\n   * @param logger - Optional custom logger (defaults to console)\n   * @returns An error interceptor\n   *\n   * @example\n   * ```typescript\n   * manager.error.use(commonInterceptors.logError());\n   * ```\n   */\n  logError(\n    logger: Pick<Console, \"error\"> = console\n  ): ErrorInterceptor {\n    return async (context) => {\n      const errorMessage =\n        context.error instanceof Error\n          ? context.error.message\n          : String(context.error);\n      logger.error(\n        `[API Error] ${context.config.method} ${context.config.url}: ${errorMessage}`\n      );\n      throw context.error;\n    };\n  },\n\n  /**\n   * Unwrap nested response data\n   *\n   * @param path - Dot-notation path to the data (e.g., 'data.result')\n   * @returns A response interceptor\n   *\n   * @example\n   * ```typescript\n   * // If API returns { data: { result: actualData } }\n   * manager.response.use(commonInterceptors.unwrapData('data.result'));\n   * ```\n   */\n  unwrapData(path: string): ResponseInterceptor {\n    return (response) => {\n      const parts = path.split(\".\");\n      let current: unknown = response.data;\n\n      for (const part of parts) {\n        if (current && typeof current === \"object\" && part in current) {\n          current = (current as Record<string, unknown>)[part];\n        } else {\n          // Path not found, return original\n          return response;\n        }\n      }\n\n      response.data = current;\n      return response;\n    };\n  },\n\n  /**\n   * Retry on specific error conditions\n   *\n   * @param shouldRetry - Function to determine if retry should happen\n   * @param onRetry - Function to perform before retry (e.g., refresh token)\n   * @returns An error interceptor\n   *\n   * @example\n   * ```typescript\n   * manager.error.use(\n   *   commonInterceptors.retryOnError(\n   *     (error) => error instanceof AuthenticationError,\n   *     async () => {\n   *       await refreshToken();\n   *     }\n   *   )\n   * );\n   * ```\n   */\n  retryOnError<T>(\n    shouldRetry: (error: unknown) => boolean,\n    onRetry: () => Promise<void>\n  ): ErrorInterceptor<T> {\n    return async (context) => {\n      if (shouldRetry(context.error)) {\n        await onRetry();\n        // The actual retry logic should be handled by the caller\n        // We just throw a special error to signal retry is needed\n        throw new ApiError(\"Retry requested\", {\n          code: \"RETRY_REQUESTED\",\n          cause: context.error instanceof Error ? context.error : undefined,\n        });\n      }\n      throw context.error;\n    };\n  },\n};\n\n/**\n * Convert RequestOptions to RequestConfig\n *\n * @param method - HTTP method\n * @param url - Request URL\n * @param options - Request options\n * @returns A RequestConfig object\n */\nexport function toRequestConfig(\n  method: HttpMethod,\n  url: string,\n  options: RequestOptions & { body?: unknown } = {}\n): RequestConfig {\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n    Accept: \"application/json\",\n    ...options.headers,\n  };\n\n  return {\n    url,\n    method,\n    headers,\n    body: options.body,\n    timeout: options.timeout,\n    signal: options.signal,\n  };\n}\n\n/**\n * Convert InterceptorResponse to ApiResponse\n *\n * @param response - The interceptor response\n * @returns An ApiResponse object\n */\nexport function toApiResponse<T>(\n  response: InterceptorResponse<T> | MutableInterceptorResponse<T>\n): ApiResponse<T> {\n  return {\n    data: response.data,\n    status: response.status,\n    headers: response.headers,\n  };\n}\n"]}